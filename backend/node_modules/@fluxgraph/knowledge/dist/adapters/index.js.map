{"version":3,"sources":["../../src/adapters/index.ts","../../src/adapters/base.ts","../../src/adapters/sqlite.ts","../../src/schema/index.ts","../../src/adapters/d1.ts","../../src/adapters/sql-storage.ts"],"sourcesContent":["export type { DatabaseAdapter, AdapterConfig, TransactionContext, DatabaseStats } from './base';\nexport { BaseAdapter } from './base';\nexport { SQLiteAdapter } from './sqlite';\nexport { D1Adapter } from './d1';\nexport { SqlStorageAdapter } from './sql-storage';\n\nimport type { DatabaseAdapter, AdapterConfig } from './base';\nimport { SQLiteAdapter } from './sqlite';\nimport { D1Adapter } from './d1';\nimport { SqlStorageAdapter } from './sql-storage';\n\n// Factory function to create appropriate adapter\nexport async function createAdapter(type: 'sqlite' | 'd1' | 'libsql' | 'sql-storage', config?: AdapterConfig): Promise<DatabaseAdapter> {\n  switch (type) {\n    case 'sqlite':\n      // For now, always use better-sqlite3 adapter\n      // Bun support will be added in a future release\n      return new SQLiteAdapter(config);\n    case 'd1':\n      return new D1Adapter(config || {});\n    case 'sql-storage':\n      return new SqlStorageAdapter(config || {});\n    case 'libsql':\n      // TODO: Implement LibSQL adapter\n      throw new Error('LibSQL adapter not yet implemented');\n    default:\n      throw new Error(`Unknown adapter type: ${type}`);\n  }\n}\n","import type { Node, Edge, NodeIndex, EdgeIndex, SearchIndex, NewNode, NewEdge, NewNodeIndex, NewEdgeIndex, NewSearchIndex } from '../schema';\n\n/**\n * Base adapter interface for database operations\n * All adapters must implement this interface\n */\nexport interface DatabaseAdapter {\n  /**\n   * Initialize the database schema\n   */\n  initialize(): Promise<void>;\n\n  /**\n   * Execute a raw SQL query\n   */\n  execute<T = unknown>(query: string, params?: unknown[]): Promise<T[]>;\n\n  /**\n   * Begin a transaction\n   */\n  transaction<T>(fn: (tx: TransactionContext) => Promise<T>): Promise<T>;\n\n  /**\n   * Node operations\n   */\n  insertNode(node: NewNode): Promise<Node>;\n  updateNode(id: string, updates: Partial<NewNode>): Promise<Node | null>;\n  deleteNode(id: string): Promise<boolean>;\n  getNode(id: string): Promise<Node | null>;\n  getNodes(ids: string[]): Promise<Node[]>;\n  queryNodes(conditions: Record<string, unknown>, limit?: number, offset?: number): Promise<Node[]>;\n\n  /**\n   * Edge operations\n   */\n  insertEdge(edge: NewEdge): Promise<Edge>;\n  updateEdge(id: string, updates: Partial<NewEdge>): Promise<Edge | null>;\n  deleteEdge(id: string): Promise<boolean>;\n  getEdge(id: string): Promise<Edge | null>;\n  getEdges(ids: string[]): Promise<Edge[]>;\n  queryEdges(conditions: Record<string, unknown>, limit?: number, offset?: number): Promise<Edge[]>;\n\n  /**\n   * Index operations\n   */\n  insertNodeIndex(index: NewNodeIndex): Promise<NodeIndex>;\n  deleteNodeIndex(indexKey: string, nodeId?: string): Promise<number>;\n  getNodeIndices(indexKey: string): Promise<NodeIndex[]>;\n\n  insertEdgeIndex(index: NewEdgeIndex): Promise<EdgeIndex>;\n  deleteEdgeIndex(indexKey: string, edgeId?: string): Promise<number>;\n  getEdgeIndices(indexKey: string): Promise<EdgeIndex[]>;\n\n  /**\n   * Search operations\n   */\n  insertSearchIndex(index: NewSearchIndex): Promise<SearchIndex>;\n  deleteSearchIndex(nodeId: string): Promise<number>;\n  searchNodes(term: string, limit?: number): Promise<SearchIndex[]>;\n\n  /**\n   * Batch operations\n   */\n  batchInsertNodes(nodes: NewNode[]): Promise<Node[]>;\n  batchInsertEdges(edges: NewEdge[]): Promise<Edge[]>;\n  batchDeleteNodes(ids: string[]): Promise<number>;\n  batchDeleteEdges(ids: string[]): Promise<number>;\n\n  /**\n   * Cleanup and maintenance\n   */\n  vacuum(): Promise<void>;\n  getStats(): Promise<DatabaseStats>;\n  close(): Promise<void>;\n}\n\n/**\n * Transaction context for atomic operations\n */\nexport interface TransactionContext {\n  execute<T = unknown>(query: string, params?: unknown[]): Promise<T[]>;\n  rollback(): Promise<void>;\n}\n\n/**\n * Database statistics\n */\nexport interface DatabaseStats {\n  nodeCount: number;\n  edgeCount: number;\n  indexCount: number;\n  sizeInBytes?: number;\n  lastVacuum?: Date;\n}\n\n/**\n * Adapter configuration\n */\nexport interface AdapterConfig {\n  /**\n   * Database connection string or configuration\n   */\n  connection?: string | Record<string, unknown>;\n\n  /**\n   * Enable debug logging\n   */\n  debug?: boolean;\n\n  /**\n   * Custom table prefix\n   */\n  tablePrefix?: string;\n\n  /**\n   * Auto-create tables if they don't exist\n   */\n  autoCreate?: boolean;\n\n  /**\n   * Additional adapter-specific options\n   */\n  options?: Record<string, unknown>;\n}\n\n/**\n * Base adapter class with common functionality\n */\nexport abstract class BaseAdapter implements DatabaseAdapter {\n  protected config: AdapterConfig;\n  protected tablePrefix: string;\n\n  constructor(config: AdapterConfig = {}) {\n    this.config = config;\n    this.tablePrefix = config.tablePrefix || '';\n  }\n\n  protected getTableName(table: string): string {\n    return this.tablePrefix ? `${this.tablePrefix}_${table}` : table;\n  }\n\n\n  protected log(_message: string, ..._args: unknown[]): void {\n    // Logging disabled for now to avoid console warnings\n    // if (this.config.debug) {\n    //   console.log(`[KnowledgeGraph] ${message}`, ...args);\n    // }\n  }\n\n  protected error(message: string, error?: unknown): void {\n    // Use console.error which is allowed by linter\n    console.error(`[KnowledgeGraph Error] ${message}`, error);\n  }\n\n  // Abstract methods that must be implemented by subclasses\n  abstract initialize(): Promise<void>;\n  abstract execute<T = unknown>(query: string, params?: any[]): Promise<T[]>;\n  abstract transaction<T>(fn: (tx: TransactionContext) => Promise<T>): Promise<T>;\n\n  abstract insertNode(node: NewNode): Promise<Node>;\n  abstract updateNode(id: string, updates: Partial<NewNode>): Promise<Node | null>;\n  abstract deleteNode(id: string): Promise<boolean>;\n  abstract getNode(id: string): Promise<Node | null>;\n  abstract getNodes(ids: string[]): Promise<Node[]>;\n  abstract queryNodes(conditions: Record<string, any>, limit?: number, offset?: number): Promise<Node[]>;\n\n  abstract insertEdge(edge: NewEdge): Promise<Edge>;\n  abstract updateEdge(id: string, updates: Partial<NewEdge>): Promise<Edge | null>;\n  abstract deleteEdge(id: string): Promise<boolean>;\n  abstract getEdge(id: string): Promise<Edge | null>;\n  abstract getEdges(ids: string[]): Promise<Edge[]>;\n  abstract queryEdges(conditions: Record<string, any>, limit?: number, offset?: number): Promise<Edge[]>;\n\n  abstract insertNodeIndex(index: NewNodeIndex): Promise<NodeIndex>;\n  abstract deleteNodeIndex(indexKey: string, nodeId?: string): Promise<number>;\n  abstract getNodeIndices(indexKey: string): Promise<NodeIndex[]>;\n\n  abstract insertEdgeIndex(index: NewEdgeIndex): Promise<EdgeIndex>;\n  abstract deleteEdgeIndex(indexKey: string, edgeId?: string): Promise<number>;\n  abstract getEdgeIndices(indexKey: string): Promise<EdgeIndex[]>;\n\n  abstract insertSearchIndex(index: NewSearchIndex): Promise<SearchIndex>;\n  abstract deleteSearchIndex(nodeId: string): Promise<number>;\n  abstract searchNodes(term: string, limit?: number): Promise<SearchIndex[]>;\n\n  abstract batchInsertNodes(nodes: NewNode[]): Promise<Node[]>;\n  abstract batchInsertEdges(edges: NewEdge[]): Promise<Edge[]>;\n  abstract batchDeleteNodes(ids: string[]): Promise<number>;\n  abstract batchDeleteEdges(ids: string[]): Promise<number>;\n\n  abstract vacuum(): Promise<void>;\n  abstract getStats(): Promise<DatabaseStats>;\n  abstract close(): Promise<void>;\n}\n","import Database from 'better-sqlite3';\nimport { drizzle } from 'drizzle-orm/better-sqlite3';\nimport { eq, and, inArray, like } from 'drizzle-orm';\nimport { BaseAdapter, TransactionContext, DatabaseStats, AdapterConfig } from './base';\nimport * as schema from '../schema';\nimport type { Node, Edge, NodeIndex, EdgeIndex, SearchIndex, NewNode, NewEdge, NewNodeIndex, NewEdgeIndex, NewSearchIndex } from '../schema';\n\n/**\n * SQLite adapter implementation using better-sqlite3\n */\nexport class SQLiteAdapter extends BaseAdapter {\n  private db: Database.Database | null = null;\n  private drizzle: ReturnType<typeof drizzle> | null = null;\n\n  constructor(config: AdapterConfig = {}) {\n    super(config);\n  }\n\n  async initialize(): Promise<void> {\n    try {\n      const dbPath = (this.config.connection as string) || ':memory:';\n      this.db = new Database(dbPath);\n      this.drizzle = drizzle(this.db);\n\n      // Enable foreign keys\n      this.db.exec('PRAGMA foreign_keys = ON');\n\n      if (this.config.autoCreate !== false) {\n        await this.createTables();\n      }\n\n      this.log('SQLite adapter initialized', { path: dbPath });\n    } catch (error) {\n      this.error('Failed to initialize SQLite adapter', error);\n      throw error;\n    }\n  }\n\n  private async createTables(): Promise<void> {\n    if (!this.db) throw new Error('Database not initialized');\n\n    // Create nodes table\n    this.db.exec(`\n      CREATE TABLE IF NOT EXISTS kg_nodes (\n        id TEXT PRIMARY KEY,\n        type TEXT NOT NULL,\n        label TEXT NOT NULL,\n        properties TEXT NOT NULL DEFAULT '{}',\n        confidence REAL NOT NULL DEFAULT 1.0,\n        created_at INTEGER NOT NULL,\n        updated_at INTEGER NOT NULL,\n        source_session_ids TEXT\n      );\n      CREATE INDEX IF NOT EXISTS idx_nodes_type ON kg_nodes(type);\n      CREATE INDEX IF NOT EXISTS idx_nodes_label ON kg_nodes(label);\n      CREATE INDEX IF NOT EXISTS idx_nodes_created_at ON kg_nodes(created_at);\n    `);\n\n    // Create edges table\n    this.db.exec(`\n      CREATE TABLE IF NOT EXISTS kg_edges (\n        id TEXT PRIMARY KEY,\n        type TEXT NOT NULL,\n        from_node_id TEXT NOT NULL REFERENCES kg_nodes(id) ON DELETE CASCADE,\n        to_node_id TEXT NOT NULL REFERENCES kg_nodes(id) ON DELETE CASCADE,\n        properties TEXT NOT NULL DEFAULT '{}',\n        confidence REAL NOT NULL DEFAULT 1.0,\n        created_at INTEGER NOT NULL,\n        source_session_ids TEXT\n      );\n      CREATE INDEX IF NOT EXISTS idx_edges_type ON kg_edges(type);\n      CREATE INDEX IF NOT EXISTS idx_edges_from_node ON kg_edges(from_node_id);\n      CREATE INDEX IF NOT EXISTS idx_edges_to_node ON kg_edges(to_node_id);\n      CREATE INDEX IF NOT EXISTS idx_edges_from_type ON kg_edges(from_node_id, type);\n      CREATE INDEX IF NOT EXISTS idx_edges_to_type ON kg_edges(to_node_id, type);\n    `);\n\n    // Create node indices table\n    this.db.exec(`\n      CREATE TABLE IF NOT EXISTS kg_node_indices (\n        index_key TEXT NOT NULL,\n        node_id TEXT NOT NULL REFERENCES kg_nodes(id) ON DELETE CASCADE,\n        created_at INTEGER NOT NULL,\n        PRIMARY KEY (index_key, node_id)\n      );\n      CREATE INDEX IF NOT EXISTS idx_node_indices_key ON kg_node_indices(index_key);\n      CREATE INDEX IF NOT EXISTS idx_node_indices_node ON kg_node_indices(node_id);\n    `);\n\n    // Create edge indices table\n    this.db.exec(`\n      CREATE TABLE IF NOT EXISTS kg_edge_indices (\n        index_key TEXT NOT NULL,\n        edge_id TEXT NOT NULL REFERENCES kg_edges(id) ON DELETE CASCADE,\n        created_at INTEGER NOT NULL,\n        PRIMARY KEY (index_key, edge_id)\n      );\n      CREATE INDEX IF NOT EXISTS idx_edge_indices_key ON kg_edge_indices(index_key);\n      CREATE INDEX IF NOT EXISTS idx_edge_indices_edge ON kg_edge_indices(edge_id);\n    `);\n\n    // Create search index table\n    this.db.exec(`\n      CREATE TABLE IF NOT EXISTS kg_search_index (\n        term TEXT NOT NULL,\n        node_id TEXT NOT NULL REFERENCES kg_nodes(id) ON DELETE CASCADE,\n        field TEXT NOT NULL,\n        weight REAL NOT NULL DEFAULT 1.0,\n        PRIMARY KEY (term, node_id, field)\n      );\n      CREATE INDEX IF NOT EXISTS idx_search_term ON kg_search_index(term);\n      CREATE INDEX IF NOT EXISTS idx_search_node ON kg_search_index(node_id);\n    `);\n\n    // Create graph metadata table\n    this.db.exec(`\n      CREATE TABLE IF NOT EXISTS kg_graph_metadata (\n        key TEXT PRIMARY KEY,\n        value TEXT NOT NULL,\n        updated_at INTEGER NOT NULL\n      );\n    `);\n  }\n\n  async execute<T = unknown>(query: string, params: unknown[] = []): Promise<T[]> {\n    if (!this.db) throw new Error('Database not initialized');\n\n    try {\n      const stmt = this.db.prepare(query);\n      return stmt.all(...params) as T[];\n    } catch (error) {\n      this.error('Query execution failed', { query, params, error });\n      throw error;\n    }\n  }\n\n  async executeUpdate(query: string, params: unknown[] = []): Promise<{ changes: number }> {\n    if (!this.db) throw new Error('Database not initialized');\n\n    try {\n      const stmt = this.db.prepare(query);\n      return stmt.run(...params);\n    } catch (error) {\n      this.error('Query execution failed', { query, params, error });\n      throw error;\n    }\n  }\n\n  async transaction<T>(fn: (tx: TransactionContext) => Promise<T>): Promise<T> {\n    if (!this.db) throw new Error('Database not initialized');\n\n    return new Promise((resolve, reject) => {\n      try {\n        if (!this.db) throw new Error('Database not initialized');\n        const result = this.db.transaction(async () => {\n          const tx: TransactionContext = {\n            execute: async <U = unknown>(query: string, params: unknown[] = []): Promise<U[]> => {\n              return this.execute<U>(query, params);\n            },\n            rollback: async () => {\n              throw new Error('Transaction rollback');\n            },\n          };\n\n          return await fn(tx);\n        })();\n\n        resolve(result);\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  // Node operations\n  async insertNode(node: NewNode): Promise<Node> {\n    if (!this.drizzle) throw new Error('Database not initialized');\n\n    const result = await this.drizzle.insert(schema.nodes).values(node).returning();\n    const insertedNode = result[0];\n    if (!insertedNode) throw new Error('Failed to create node');\n    return this.deserializeNode(insertedNode);\n  }\n\n  async updateNode(id: string, updates: Partial<NewNode>): Promise<Node | null> {\n    if (!this.drizzle) throw new Error('Database not initialized');\n\n    const result = await this.drizzle\n      .update(schema.nodes)\n      .set({ ...updates, updatedAt: new Date() })\n      .where(eq(schema.nodes.id, id))\n      .returning();\n\n    return result[0] ? this.deserializeNode(result[0]) : null;\n  }\n\n  async deleteNode(id: string): Promise<boolean> {\n    const query = `DELETE FROM kg_nodes WHERE id = ?`;\n    const result = await this.executeUpdate(query, [id]);\n    return result.changes > 0;\n  }\n\n  async getNode(id: string): Promise<Node | null> {\n    if (!this.drizzle) throw new Error('Database not initialized');\n\n    const result = await this.drizzle.select().from(schema.nodes).where(eq(schema.nodes.id, id)).limit(1);\n\n    return result[0] ? this.deserializeNode(result[0]) : null;\n  }\n\n  async getNodes(ids: string[]): Promise<Node[]> {\n    if (!this.drizzle || ids.length === 0) return [];\n\n    const result = await this.drizzle.select().from(schema.nodes).where(inArray(schema.nodes.id, ids));\n\n    return result.map((n) => this.deserializeNode(n));\n  }\n\n  async queryNodes(conditions: Record<string, unknown>, limit = 100, offset = 0): Promise<Node[]> {\n    if (!this.drizzle) throw new Error('Database not initialized');\n\n    const whereConditions = Object.entries(conditions).map(([key, value]) => {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const column = (schema.nodes as any)[key];\n      return eq(column, value);\n    });\n\n    const result = await this.drizzle\n      .select()\n      .from(schema.nodes)\n      .where(and(...whereConditions))\n      .limit(limit)\n      .offset(offset);\n\n    return result.map((n) => this.deserializeNode(n));\n  }\n\n  // Edge operations\n  async insertEdge(edge: NewEdge): Promise<Edge> {\n    if (!this.drizzle) throw new Error('Database not initialized');\n\n    const result = await this.drizzle.insert(schema.edges).values(edge).returning();\n    const insertedEdge = result[0];\n    if (!insertedEdge) throw new Error('Failed to create edge');\n    return this.deserializeEdge(insertedEdge);\n  }\n\n  async updateEdge(id: string, updates: Partial<NewEdge>): Promise<Edge | null> {\n    if (!this.drizzle) throw new Error('Database not initialized');\n\n    const result = await this.drizzle.update(schema.edges).set(updates).where(eq(schema.edges.id, id)).returning();\n\n    return result[0] ? this.deserializeEdge(result[0]) : null;\n  }\n\n  async deleteEdge(id: string): Promise<boolean> {\n    const query = `DELETE FROM kg_edges WHERE id = ?`;\n    await this.execute(query, [id]);\n    return true;\n  }\n\n  async getEdge(id: string): Promise<Edge | null> {\n    if (!this.drizzle) throw new Error('Database not initialized');\n\n    const result = await this.drizzle.select().from(schema.edges).where(eq(schema.edges.id, id)).limit(1);\n\n    return result[0] ? this.deserializeEdge(result[0]) : null;\n  }\n\n  async getEdges(ids: string[]): Promise<Edge[]> {\n    if (!this.drizzle || ids.length === 0) return [];\n\n    const result = await this.drizzle.select().from(schema.edges).where(inArray(schema.edges.id, ids));\n\n    return result.map((e) => this.deserializeEdge(e));\n  }\n\n  async queryEdges(conditions: Record<string, unknown>, limit = 100, offset = 0): Promise<Edge[]> {\n    if (!this.drizzle) throw new Error('Database not initialized');\n\n    const whereConditions = Object.entries(conditions).map(([key, value]) => {\n      // Map camelCase to snake_case for schema fields (Drizzle schema uses camelCase in TypeScript)\n      const fieldMap: Record<string, string> = {\n        'from_node_id': 'fromNodeId',\n        'to_node_id': 'toNodeId',\n        'created_at': 'createdAt',\n        'updated_at': 'updatedAt',\n        'source_session_ids': 'sourceSessionIds'\n      };\n      const schemaKey = fieldMap[key] || key;\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const column = (schema.edges as any)[schemaKey];\n      return eq(column, value);\n    });\n\n    const result = await this.drizzle\n      .select()\n      .from(schema.edges)\n      .where(and(...whereConditions))\n      .limit(limit)\n      .offset(offset);\n\n    return result.map((e) => this.deserializeEdge(e));\n  }\n\n  // Index operations\n  async insertNodeIndex(index: NewNodeIndex): Promise<NodeIndex> {\n    if (!this.drizzle) throw new Error('Database not initialized');\n\n    const result = await this.drizzle.insert(schema.nodeIndices).values(index).returning();\n    const insertedIndex = result[0];\n    if (!insertedIndex) throw new Error('Failed to create node index');\n    return insertedIndex;\n  }\n\n  async deleteNodeIndex(indexKey: string, nodeId?: string): Promise<number> {\n    const query = nodeId ? `DELETE FROM kg_node_indices WHERE index_key = ? AND node_id = ?` : `DELETE FROM kg_node_indices WHERE index_key = ?`;\n    const params = nodeId ? [indexKey, nodeId] : [indexKey];\n\n    if (!this.db) throw new Error('Database not initialized');\n    const stmt = this.db.prepare(query);\n    const info = stmt.run(params);\n    return info.changes;\n  }\n\n  async getNodeIndices(indexKey: string): Promise<NodeIndex[]> {\n    if (!this.drizzle) throw new Error('Database not initialized');\n\n    return await this.drizzle.select().from(schema.nodeIndices).where(eq(schema.nodeIndices.indexKey, indexKey));\n  }\n\n  async insertEdgeIndex(index: NewEdgeIndex): Promise<EdgeIndex> {\n    if (!this.drizzle) throw new Error('Database not initialized');\n\n    const result = await this.drizzle.insert(schema.edgeIndices).values(index).returning();\n    const insertedIndex = result[0];\n    if (!insertedIndex) throw new Error('Failed to create edge index');\n    return insertedIndex;\n  }\n\n  async deleteEdgeIndex(indexKey: string, edgeId?: string): Promise<number> {\n    const query = edgeId ? `DELETE FROM kg_edge_indices WHERE index_key = ? AND edge_id = ?` : `DELETE FROM kg_edge_indices WHERE index_key = ?`;\n    const params = edgeId ? [indexKey, edgeId] : [indexKey];\n\n    if (!this.db) throw new Error('Database not initialized');\n    const stmt = this.db.prepare(query);\n    const info = stmt.run(params);\n    return info.changes;\n  }\n\n  async getEdgeIndices(indexKey: string): Promise<EdgeIndex[]> {\n    if (!this.drizzle) throw new Error('Database not initialized');\n\n    return await this.drizzle.select().from(schema.edgeIndices).where(eq(schema.edgeIndices.indexKey, indexKey));\n  }\n\n  // Search operations\n  async insertSearchIndex(index: NewSearchIndex): Promise<SearchIndex> {\n    if (!this.drizzle) throw new Error('Database not initialized');\n\n    const result = await this.drizzle.insert(schema.searchIndex).values(index).returning();\n    const insertedIndex = result[0];\n    if (!insertedIndex) throw new Error('Failed to create search index');\n    return insertedIndex;\n  }\n\n  async deleteSearchIndex(nodeId: string): Promise<number> {\n    const query = `DELETE FROM kg_search_index WHERE node_id = ?`;\n    if (!this.db) throw new Error('Database not initialized');\n    const stmt = this.db.prepare(query);\n    const info = stmt.run([nodeId]);\n    return info.changes;\n  }\n\n  async searchNodes(term: string, limit = 50): Promise<SearchIndex[]> {\n    if (!this.drizzle) throw new Error('Database not initialized');\n\n    return await this.drizzle\n      .select()\n      .from(schema.searchIndex)\n      .where(like(schema.searchIndex.term, `%${term}%`))\n      .limit(limit);\n  }\n\n  // Batch operations\n  async batchInsertNodes(nodes: NewNode[]): Promise<Node[]> {\n    if (!this.drizzle || nodes.length === 0) return [];\n\n    const result = await this.drizzle.insert(schema.nodes).values(nodes).returning();\n    return result.map((n) => this.deserializeNode(n));\n  }\n\n  async batchInsertEdges(edges: NewEdge[]): Promise<Edge[]> {\n    if (!this.drizzle || edges.length === 0) return [];\n\n    const result = await this.drizzle.insert(schema.edges).values(edges).returning();\n    return result.map((e) => this.deserializeEdge(e));\n  }\n\n  async batchDeleteNodes(ids: string[]): Promise<number> {\n    if (ids.length === 0) return 0;\n\n    const placeholders = ids.map(() => '?').join(',');\n    const query = `DELETE FROM kg_nodes WHERE id IN (${placeholders})`;\n    if (!this.db) throw new Error('Database not initialized');\n    const stmt = this.db.prepare(query);\n    const info = stmt.run(ids);\n    return info.changes;\n  }\n\n  async batchDeleteEdges(ids: string[]): Promise<number> {\n    if (ids.length === 0) return 0;\n\n    const placeholders = ids.map(() => '?').join(',');\n    const query = `DELETE FROM kg_edges WHERE id IN (${placeholders})`;\n    if (!this.db) throw new Error('Database not initialized');\n    const stmt = this.db.prepare(query);\n    const info = stmt.run(ids);\n    return info.changes;\n  }\n\n  // Maintenance operations\n  async vacuum(): Promise<void> {\n    if (!this.db) throw new Error('Database not initialized');\n\n    this.db.exec('VACUUM');\n    this.log('Database vacuumed');\n  }\n\n  async getStats(): Promise<DatabaseStats> {\n    if (!this.db) throw new Error('Database not initialized');\n\n    const nodeCount = this.db.prepare('SELECT COUNT(*) as count FROM kg_nodes').get() as {count: number};\n    const edgeCount = this.db.prepare('SELECT COUNT(*) as count FROM kg_edges').get() as {count: number};\n    const indexCount = this.db.prepare('SELECT COUNT(*) as count FROM kg_node_indices').get() as {count: number};\n\n    return {\n      nodeCount: nodeCount.count,\n      edgeCount: edgeCount.count,\n      indexCount: indexCount.count,\n    };\n  }\n\n  async close(): Promise<void> {\n    if (this.db) {\n      this.db.close();\n      this.db = null;\n      this.drizzle = null;\n      this.log('Database connection closed');\n    }\n  }\n\n  // Helper methods\n  private deserializeNode(node: schema.Node): Node {\n    return {\n      ...node,\n      properties: JSON.parse(node.properties),\n      sourceSessionIds: node.sourceSessionIds ? JSON.parse(node.sourceSessionIds) : undefined,\n    };\n  }\n\n  private deserializeEdge(edge: schema.Edge): Edge {\n    return {\n      ...edge,\n      properties: JSON.parse(edge.properties),\n      sourceSessionIds: edge.sourceSessionIds ? JSON.parse(edge.sourceSessionIds) : undefined,\n    };\n  }\n}\n","import { sqliteTable, text, integer, index, primaryKey, real } from 'drizzle-orm/sqlite-core';\nimport { InferSelectModel, InferInsertModel } from 'drizzle-orm';\n\n/**\n * Nodes table - stores all graph nodes\n */\nexport const nodes = sqliteTable('kg_nodes', {\n  id: text('id').primaryKey(),\n  type: text('type').notNull(),\n  label: text('label').notNull(),\n  properties: text('properties').notNull(), // JSON string\n  confidence: real('confidence').notNull().default(1.0),\n  createdAt: integer('created_at', { mode: 'timestamp' }).notNull().$defaultFn(() => new Date()),\n  updatedAt: integer('updated_at', { mode: 'timestamp' }).notNull().$defaultFn(() => new Date()),\n  sourceSessionIds: text('source_session_ids'), // JSON array of session IDs\n}, (table) => ({\n  typeIdx: index('idx_nodes_type').on(table.type),\n  labelIdx: index('idx_nodes_label').on(table.label),\n  createdAtIdx: index('idx_nodes_created_at').on(table.createdAt),\n}));\n\n/**\n * Edges table - stores relationships between nodes\n */\nexport const edges = sqliteTable('kg_edges', {\n  id: text('id').primaryKey(),\n  type: text('type').notNull(),\n  fromNodeId: text('from_node_id').notNull().references(() => nodes.id, { onDelete: 'cascade' }),\n  toNodeId: text('to_node_id').notNull().references(() => nodes.id, { onDelete: 'cascade' }),\n  properties: text('properties').notNull().default('{}'), // JSON string\n  confidence: real('confidence').notNull().default(1.0),\n  createdAt: integer('created_at', { mode: 'timestamp' }).notNull().$defaultFn(() => new Date()),\n  sourceSessionIds: text('source_session_ids'), // JSON array of session IDs\n}, (table) => ({\n  typeIdx: index('idx_edges_type').on(table.type),\n  fromNodeIdx: index('idx_edges_from_node').on(table.fromNodeId),\n  toNodeIdx: index('idx_edges_to_node').on(table.toNodeId),\n  fromTypeIdx: index('idx_edges_from_type').on(table.fromNodeId, table.type),\n  toTypeIdx: index('idx_edges_to_type').on(table.toNodeId, table.type),\n}));\n\n/**\n * Node indices table - for efficient node lookups\n */\nexport const nodeIndices = sqliteTable('kg_node_indices', {\n  indexKey: text('index_key').notNull(),\n  nodeId: text('node_id').notNull().references(() => nodes.id, { onDelete: 'cascade' }),\n  createdAt: integer('created_at', { mode: 'timestamp' }).notNull().$defaultFn(() => new Date()),\n}, (table) => ({\n  pk: primaryKey({ columns: [table.indexKey, table.nodeId] }),\n  keyIdx: index('idx_node_indices_key').on(table.indexKey),\n  nodeIdx: index('idx_node_indices_node').on(table.nodeId),\n}));\n\n/**\n * Edge indices table - for efficient edge lookups\n */\nexport const edgeIndices = sqliteTable('kg_edge_indices', {\n  indexKey: text('index_key').notNull(),\n  edgeId: text('edge_id').notNull().references(() => edges.id, { onDelete: 'cascade' }),\n  createdAt: integer('created_at', { mode: 'timestamp' }).notNull().$defaultFn(() => new Date()),\n}, (table) => ({\n  pk: primaryKey({ columns: [table.indexKey, table.edgeId] }),\n  keyIdx: index('idx_edge_indices_key').on(table.indexKey),\n  edgeIdx: index('idx_edge_indices_edge').on(table.edgeId),\n}));\n\n/**\n * Search index table - for full-text search capabilities\n */\nexport const searchIndex = sqliteTable('kg_search_index', {\n  term: text('term').notNull(),\n  nodeId: text('node_id').notNull().references(() => nodes.id, { onDelete: 'cascade' }),\n  field: text('field').notNull(), // 'label', 'property:key', etc.\n  weight: real('weight').notNull().default(1.0),\n}, (table) => ({\n  pk: primaryKey({ columns: [table.term, table.nodeId, table.field] }),\n  termIdx: index('idx_search_term').on(table.term),\n  nodeIdx: index('idx_search_node').on(table.nodeId),\n}));\n\n/**\n * Graph metadata table - stores graph-level information\n */\nexport const graphMetadata = sqliteTable('kg_graph_metadata', {\n  key: text('key').primaryKey(),\n  value: text('value').notNull(),\n  updatedAt: integer('updated_at', { mode: 'timestamp' }).notNull().$defaultFn(() => new Date()),\n});\n\n// Type exports\nexport type Node = InferSelectModel<typeof nodes>;\nexport type NewNode = InferInsertModel<typeof nodes>;\nexport type Edge = InferSelectModel<typeof edges>;\nexport type NewEdge = InferInsertModel<typeof edges>;\nexport type NodeIndex = InferSelectModel<typeof nodeIndices>;\nexport type NewNodeIndex = InferInsertModel<typeof nodeIndices>;\nexport type EdgeIndex = InferSelectModel<typeof edgeIndices>;\nexport type NewEdgeIndex = InferInsertModel<typeof edgeIndices>;\nexport type SearchIndex = InferSelectModel<typeof searchIndex>;\nexport type NewSearchIndex = InferInsertModel<typeof searchIndex>;\nexport type GraphMetadata = InferSelectModel<typeof graphMetadata>;\nexport type NewGraphMetadata = InferInsertModel<typeof graphMetadata>;","import type { D1Database } from '@cloudflare/workers-types';\nimport { BaseAdapter, TransactionContext, DatabaseStats, AdapterConfig } from './base';\nimport type { \n  Node, Edge, NodeIndex, EdgeIndex, SearchIndex,\n  NewNode, NewEdge, NewNodeIndex, NewEdgeIndex, NewSearchIndex\n} from '../schema';\n\n/**\n * Cloudflare D1 adapter implementation\n * Uses raw SQL queries for compatibility with D1 in Durable Objects\n */\nexport class D1Adapter extends BaseAdapter {\n  private db: D1Database | null = null;\n  \n  constructor(config: AdapterConfig & { database?: D1Database }) {\n    super(config);\n    if (config.database) {\n      this.db = config.database;\n    }\n  }\n  \n  setDatabase(db: D1Database): void {\n    this.db = db;\n  }\n  \n  async initialize(): Promise<void> {\n    if (!this.db) {\n      throw new Error('D1 database not provided. Use setDatabase() or pass it in config.');\n    }\n    \n    if (this.config.autoCreate !== false) {\n      await this.createTables();\n    }\n    \n    this.log('D1 adapter initialized');\n  }\n  \n  private async createTables(): Promise<void> {\n    if (!this.db) throw new Error('Database not initialized');\n    \n    // Create nodes table\n    await this.db.exec(`\n      CREATE TABLE IF NOT EXISTS kg_nodes (\n        id TEXT PRIMARY KEY,\n        type TEXT NOT NULL,\n        label TEXT NOT NULL,\n        properties TEXT NOT NULL DEFAULT '{}',\n        confidence REAL NOT NULL DEFAULT 1.0,\n        created_at INTEGER NOT NULL,\n        updated_at INTEGER NOT NULL,\n        source_session_ids TEXT\n      );\n    `);\n    \n    await this.db.exec(`CREATE INDEX IF NOT EXISTS idx_nodes_type ON kg_nodes(type);`);\n    await this.db.exec(`CREATE INDEX IF NOT EXISTS idx_nodes_label ON kg_nodes(label);`);\n    await this.db.exec(`CREATE INDEX IF NOT EXISTS idx_nodes_created_at ON kg_nodes(created_at);`);\n    \n    // Create edges table\n    await this.db.exec(`\n      CREATE TABLE IF NOT EXISTS kg_edges (\n        id TEXT PRIMARY KEY,\n        type TEXT NOT NULL,\n        from_node_id TEXT NOT NULL,\n        to_node_id TEXT NOT NULL,\n        properties TEXT NOT NULL DEFAULT '{}',\n        confidence REAL NOT NULL DEFAULT 1.0,\n        created_at INTEGER NOT NULL,\n        source_session_ids TEXT,\n        FOREIGN KEY (from_node_id) REFERENCES kg_nodes(id) ON DELETE CASCADE,\n        FOREIGN KEY (to_node_id) REFERENCES kg_nodes(id) ON DELETE CASCADE\n      );\n    `);\n    \n    await this.db.exec(`CREATE INDEX IF NOT EXISTS idx_edges_type ON kg_edges(type);`);\n    await this.db.exec(`CREATE INDEX IF NOT EXISTS idx_edges_from_node ON kg_edges(from_node_id);`);\n    await this.db.exec(`CREATE INDEX IF NOT EXISTS idx_edges_to_node ON kg_edges(to_node_id);`);\n    await this.db.exec(`CREATE INDEX IF NOT EXISTS idx_edges_from_type ON kg_edges(from_node_id, type);`);\n    await this.db.exec(`CREATE INDEX IF NOT EXISTS idx_edges_to_type ON kg_edges(to_node_id, type);`);\n    \n    // Create indices tables\n    await this.db.exec(`\n      CREATE TABLE IF NOT EXISTS kg_node_indices (\n        index_key TEXT NOT NULL,\n        node_id TEXT NOT NULL,\n        created_at INTEGER NOT NULL,\n        PRIMARY KEY (index_key, node_id),\n        FOREIGN KEY (node_id) REFERENCES kg_nodes(id) ON DELETE CASCADE\n      );\n    `);\n    \n    await this.db.exec(`CREATE INDEX IF NOT EXISTS idx_node_indices_key ON kg_node_indices(index_key);`);\n    await this.db.exec(`CREATE INDEX IF NOT EXISTS idx_node_indices_node ON kg_node_indices(node_id);`);\n    \n    await this.db.exec(`\n      CREATE TABLE IF NOT EXISTS kg_edge_indices (\n        index_key TEXT NOT NULL,\n        edge_id TEXT NOT NULL,\n        created_at INTEGER NOT NULL,\n        PRIMARY KEY (index_key, edge_id),\n        FOREIGN KEY (edge_id) REFERENCES kg_edges(id) ON DELETE CASCADE\n      );\n    `);\n    \n    await this.db.exec(`CREATE INDEX IF NOT EXISTS idx_edge_indices_key ON kg_edge_indices(index_key);`);\n    await this.db.exec(`CREATE INDEX IF NOT EXISTS idx_edge_indices_edge ON kg_edge_indices(edge_id);`);\n    \n    // Create search index table\n    await this.db.exec(`\n      CREATE TABLE IF NOT EXISTS kg_search_index (\n        term TEXT NOT NULL,\n        node_id TEXT NOT NULL,\n        field TEXT NOT NULL,\n        weight REAL NOT NULL DEFAULT 1.0,\n        PRIMARY KEY (term, node_id, field),\n        FOREIGN KEY (node_id) REFERENCES kg_nodes(id) ON DELETE CASCADE\n      );\n    `);\n    \n    await this.db.exec(`CREATE INDEX IF NOT EXISTS idx_search_term ON kg_search_index(term);`);\n    await this.db.exec(`CREATE INDEX IF NOT EXISTS idx_search_node ON kg_search_index(node_id);`);\n    \n    // Create metadata table\n    await this.db.exec(`\n      CREATE TABLE IF NOT EXISTS kg_graph_metadata (\n        key TEXT PRIMARY KEY,\n        value TEXT NOT NULL,\n        updated_at INTEGER NOT NULL\n      );\n    `);\n  }\n  \n  async execute<T = unknown>(query: string, params: unknown[] = []): Promise<T[]> {\n    if (!this.db) throw new Error('Database not initialized');\n    \n    try {\n      const stmt = this.db.prepare(query).bind(...params);\n      const result = await stmt.all();\n      return result.results as T[];\n    } catch (error) {\n      this.error('Query execution failed', { query, params, error });\n      throw error;\n    }\n  }\n  \n  async transaction<T>(fn: (tx: TransactionContext) => Promise<T>): Promise<T> {\n    if (!this.db) throw new Error('Database not initialized');\n    \n    // D1 doesn't support explicit transactions in the same way\n    // We'll simulate it with a try-catch and manual rollback if needed\n    const tx: TransactionContext = {\n      execute: async <U = unknown>(query: string, params: unknown[] = []): Promise<U[]> => {\n        return this.execute<U>(query, params);\n      },\n      rollback: async () => {\n        throw new Error('Transaction rollback');\n      }\n    };\n    \n    try {\n      return await fn(tx);\n    } catch (error) {\n      this.error('Transaction failed', error);\n      throw error;\n    }\n  }\n  \n  // Node operations\n  async insertNode(node: NewNode): Promise<Node> {\n    const id = node.id || crypto.randomUUID();\n    const now = Date.now();\n    \n    const query = `\n      INSERT INTO kg_nodes (id, type, label, properties, confidence, created_at, updated_at, source_session_ids)\n      VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n    `;\n    \n    await this.execute(query, [\n      id,\n      node.type,\n      node.label,\n      JSON.stringify(node.properties || {}),\n      node.confidence || 1.0,\n      node.createdAt?.getTime() || now,\n      node.updatedAt?.getTime() || now,\n      node.sourceSessionIds ? JSON.stringify(node.sourceSessionIds) : null\n    ]);\n    \n    return this.getNode(id) as Promise<Node>;\n  }\n  \n  async updateNode(id: string, updates: Partial<NewNode>): Promise<Node | null> {\n    const setClauses: string[] = [];\n    const params: unknown[] = [];\n    \n    if (updates.type !== undefined) {\n      setClauses.push('type = ?');\n      params.push(updates.type);\n    }\n    if (updates.label !== undefined) {\n      setClauses.push('label = ?');\n      params.push(updates.label);\n    }\n    if (updates.properties !== undefined) {\n      setClauses.push('properties = ?');\n      params.push(JSON.stringify(updates.properties));\n    }\n    if (updates.confidence !== undefined) {\n      setClauses.push('confidence = ?');\n      params.push(updates.confidence);\n    }\n    if (updates.sourceSessionIds !== undefined) {\n      setClauses.push('source_session_ids = ?');\n      params.push(JSON.stringify(updates.sourceSessionIds));\n    }\n    \n    setClauses.push('updated_at = ?');\n    params.push(Date.now());\n    \n    params.push(id);\n    \n    const query = `UPDATE kg_nodes SET ${setClauses.join(', ')} WHERE id = ?`;\n    await this.execute(query, params);\n    \n    return this.getNode(id);\n  }\n  \n  async deleteNode(id: string): Promise<boolean> {\n    const query = `DELETE FROM kg_nodes WHERE id = ?`;\n    await this.execute(query, [id]);\n    return true;\n  }\n  \n  async getNode(id: string): Promise<Node | null> {\n    const query = `SELECT * FROM kg_nodes WHERE id = ? LIMIT 1`;\n    const results = await this.execute<Record<string, unknown>>(query, [id]);\n    \n    if (results.length === 0) return null;\n    \n    return this.deserializeNode(results[0]!);\n  }\n  \n  async getNodes(ids: string[]): Promise<Node[]> {\n    if (ids.length === 0) return [];\n    \n    const placeholders = ids.map(() => '?').join(',');\n    const query = `SELECT * FROM kg_nodes WHERE id IN (${placeholders})`;\n    const results = await this.execute<Record<string, unknown>>(query, ids);\n    \n    return results.map(n => this.deserializeNode(n));\n  }\n  \n  async queryNodes(conditions: Record<string, unknown>, limit = 100, offset = 0): Promise<Node[]> {\n    const whereClauses: string[] = [];\n    const params: unknown[] = [];\n    \n    for (const [key, value] of Object.entries(conditions)) {\n      whereClauses.push(`${key} = ?`);\n      params.push(value);\n    }\n    \n    params.push(limit, offset);\n    \n    const query = `\n      SELECT * FROM kg_nodes \n      ${whereClauses.length > 0 ? 'WHERE ' + whereClauses.join(' AND ') : ''}\n      LIMIT ? OFFSET ?\n    `;\n    \n    const results = await this.execute<Record<string, unknown>>(query, params);\n    return results.map(n => this.deserializeNode(n));\n  }\n  \n  // Edge operations\n  async insertEdge(edge: NewEdge): Promise<Edge> {\n    const id = edge.id || crypto.randomUUID();\n    const now = Date.now();\n    \n    const query = `\n      INSERT INTO kg_edges (id, type, from_node_id, to_node_id, properties, confidence, created_at, source_session_ids)\n      VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n    `;\n    \n    await this.execute(query, [\n      id,\n      edge.type,\n      edge.fromNodeId,\n      edge.toNodeId,\n      JSON.stringify(edge.properties || {}),\n      edge.confidence || 1.0,\n      edge.createdAt?.getTime() || now,\n      edge.sourceSessionIds ? JSON.stringify(edge.sourceSessionIds) : null\n    ]);\n    \n    return this.getEdge(id) as Promise<Edge>;\n  }\n  \n  async updateEdge(id: string, updates: Partial<NewEdge>): Promise<Edge | null> {\n    const setClauses: string[] = [];\n    const params: unknown[] = [];\n    \n    if (updates.type !== undefined) {\n      setClauses.push('type = ?');\n      params.push(updates.type);\n    }\n    if (updates.fromNodeId !== undefined) {\n      setClauses.push('from_node_id = ?');\n      params.push(updates.fromNodeId);\n    }\n    if (updates.toNodeId !== undefined) {\n      setClauses.push('to_node_id = ?');\n      params.push(updates.toNodeId);\n    }\n    if (updates.properties !== undefined) {\n      setClauses.push('properties = ?');\n      params.push(JSON.stringify(updates.properties));\n    }\n    if (updates.confidence !== undefined) {\n      setClauses.push('confidence = ?');\n      params.push(updates.confidence);\n    }\n    if (updates.sourceSessionIds !== undefined) {\n      setClauses.push('source_session_ids = ?');\n      params.push(JSON.stringify(updates.sourceSessionIds));\n    }\n    \n    params.push(id);\n    \n    const query = `UPDATE kg_edges SET ${setClauses.join(', ')} WHERE id = ?`;\n    await this.execute(query, params);\n    \n    return this.getEdge(id);\n  }\n  \n  async deleteEdge(id: string): Promise<boolean> {\n    const query = `DELETE FROM kg_edges WHERE id = ?`;\n    await this.execute(query, [id]);\n    return true;\n  }\n  \n  async getEdge(id: string): Promise<Edge | null> {\n    const query = `SELECT * FROM kg_edges WHERE id = ? LIMIT 1`;\n    const results = await this.execute<Record<string, unknown>>(query, [id]);\n    \n    if (results.length === 0) return null;\n    \n    return this.deserializeEdge(results[0]!);\n  }\n  \n  async getEdges(ids: string[]): Promise<Edge[]> {\n    if (ids.length === 0) return [];\n    \n    const placeholders = ids.map(() => '?').join(',');\n    const query = `SELECT * FROM kg_edges WHERE id IN (${placeholders})`;\n    const results = await this.execute<Record<string, unknown>>(query, ids);\n    \n    return results.map(e => this.deserializeEdge(e));\n  }\n  \n  async queryEdges(conditions: Record<string, unknown>, limit = 100, offset = 0): Promise<Edge[]> {\n    const whereClauses: string[] = [];\n    const params: unknown[] = [];\n    \n    // Map camelCase to snake_case for query conditions\n    const fieldMap: Record<string, string> = {\n      'fromNodeId': 'from_node_id',\n      'toNodeId': 'to_node_id',\n      'from_node_id': 'from_node_id',\n      'to_node_id': 'to_node_id',\n      'createdAt': 'created_at',\n      'updatedAt': 'updated_at',\n      'sourceSessionIds': 'source_session_ids'\n    };\n    \n    for (const [key, value] of Object.entries(conditions)) {\n      const dbKey = fieldMap[key] || key;\n      whereClauses.push(`${dbKey} = ?`);\n      params.push(value);\n    }\n    \n    params.push(limit, offset);\n    \n    const query = `\n      SELECT * FROM kg_edges \n      ${whereClauses.length > 0 ? 'WHERE ' + whereClauses.join(' AND ') : ''}\n      LIMIT ? OFFSET ?\n    `;\n    \n    const results = await this.execute<Record<string, unknown>>(query, params);\n    return results.map(e => this.deserializeEdge(e));\n  }\n  \n  // Index operations\n  async insertNodeIndex(index: NewNodeIndex): Promise<NodeIndex> {\n    const query = `\n      INSERT INTO kg_node_indices (index_key, node_id, created_at)\n      VALUES (?, ?, ?)\n    `;\n    \n    await this.execute(query, [\n      index.indexKey,\n      index.nodeId,\n      index.createdAt?.getTime() || Date.now()\n    ]);\n    \n    return index as NodeIndex;\n  }\n  \n  async deleteNodeIndex(indexKey: string, nodeId?: string): Promise<number> {\n    const query = nodeId\n      ? `DELETE FROM kg_node_indices WHERE index_key = ? AND node_id = ?`\n      : `DELETE FROM kg_node_indices WHERE index_key = ?`;\n    const params = nodeId ? [indexKey, nodeId] : [indexKey];\n    \n    await this.execute(query, params);\n    return 1; // D1 doesn't provide change count easily\n  }\n  \n  async getNodeIndices(indexKey: string): Promise<NodeIndex[]> {\n    const query = `SELECT * FROM kg_node_indices WHERE index_key = ?`;\n    const results = await this.execute<Record<string, unknown>>(query, [indexKey]);\n    return results.map(r => this.deserializeNodeIndex(r));\n  }\n  \n  async insertEdgeIndex(index: NewEdgeIndex): Promise<EdgeIndex> {\n    const query = `\n      INSERT INTO kg_edge_indices (index_key, edge_id, created_at)\n      VALUES (?, ?, ?)\n    `;\n    \n    await this.execute(query, [\n      index.indexKey,\n      index.edgeId,\n      index.createdAt?.getTime() || Date.now()\n    ]);\n    \n    return index as EdgeIndex;\n  }\n  \n  async deleteEdgeIndex(indexKey: string, edgeId?: string): Promise<number> {\n    const query = edgeId\n      ? `DELETE FROM kg_edge_indices WHERE index_key = ? AND edge_id = ?`\n      : `DELETE FROM kg_edge_indices WHERE index_key = ?`;\n    const params = edgeId ? [indexKey, edgeId] : [indexKey];\n    \n    await this.execute(query, params);\n    return 1;\n  }\n  \n  async getEdgeIndices(indexKey: string): Promise<EdgeIndex[]> {\n    const query = `SELECT * FROM kg_edge_indices WHERE index_key = ?`;\n    const results = await this.execute<Record<string, unknown>>(query, [indexKey]);\n    return results.map(r => this.deserializeEdgeIndex(r));\n  }\n  \n  // Search operations\n  async insertSearchIndex(index: NewSearchIndex): Promise<SearchIndex> {\n    const query = `\n      INSERT OR REPLACE INTO kg_search_index (term, node_id, field, weight)\n      VALUES (?, ?, ?, ?)\n    `;\n    \n    await this.execute(query, [\n      index.term,\n      index.nodeId,\n      index.field,\n      index.weight || 1.0\n    ]);\n    \n    return index as SearchIndex;\n  }\n  \n  async deleteSearchIndex(nodeId: string): Promise<number> {\n    const query = `DELETE FROM kg_search_index WHERE node_id = ?`;\n    await this.execute(query, [nodeId]);\n    return 1;\n  }\n  \n  async searchNodes(term: string, limit = 50): Promise<SearchIndex[]> {\n    const query = `\n      SELECT * FROM kg_search_index \n      WHERE term LIKE ? \n      ORDER BY weight DESC \n      LIMIT ?\n    `;\n    \n    const results = await this.execute<Record<string, unknown>>(query, [`%${term}%`, limit]);\n    return results.map(r => this.deserializeSearchIndex(r));\n  }\n  \n  // Batch operations\n  async batchInsertNodes(nodes: NewNode[]): Promise<Node[]> {\n    const insertedNodes: Node[] = [];\n    \n    for (const node of nodes) {\n      const inserted = await this.insertNode(node);\n      insertedNodes.push(inserted);\n    }\n    \n    return insertedNodes;\n  }\n  \n  async batchInsertEdges(edges: NewEdge[]): Promise<Edge[]> {\n    const insertedEdges: Edge[] = [];\n    \n    for (const edge of edges) {\n      const inserted = await this.insertEdge(edge);\n      insertedEdges.push(inserted);\n    }\n    \n    return insertedEdges;\n  }\n  \n  async batchDeleteNodes(ids: string[]): Promise<number> {\n    if (ids.length === 0) return 0;\n    \n    const placeholders = ids.map(() => '?').join(',');\n    const query = `DELETE FROM kg_nodes WHERE id IN (${placeholders})`;\n    await this.execute(query, ids);\n    return ids.length;\n  }\n  \n  async batchDeleteEdges(ids: string[]): Promise<number> {\n    if (ids.length === 0) return 0;\n    \n    const placeholders = ids.map(() => '?').join(',');\n    const query = `DELETE FROM kg_edges WHERE id IN (${placeholders})`;\n    await this.execute(query, ids);\n    return ids.length;\n  }\n  \n  // Maintenance operations\n  async vacuum(): Promise<void> {\n    // D1 handles vacuum automatically\n    this.log('Vacuum not needed for D1 (handled automatically)');\n  }\n  \n  async getStats(): Promise<DatabaseStats> {\n    const nodeCount = await this.execute<{count: number}>('SELECT COUNT(*) as count FROM kg_nodes');\n    const edgeCount = await this.execute<{count: number}>('SELECT COUNT(*) as count FROM kg_edges');\n    const indexCount = await this.execute<{count: number}>('SELECT COUNT(*) as count FROM kg_node_indices');\n    \n    return {\n      nodeCount: nodeCount[0]?.count || 0,\n      edgeCount: edgeCount[0]?.count || 0,\n      indexCount: indexCount[0]?.count || 0,\n    };\n  }\n  \n  async close(): Promise<void> {\n    // D1 doesn't need explicit close\n    this.db = null;\n    this.log('D1 adapter closed');\n  }\n  \n  // Helper methods\n  private deserializeNode(row: Record<string, unknown>): Node {\n    return {\n      id: row.id as string,\n      type: row.type as string,\n      label: row.label as string,\n      properties: typeof row.properties === 'string' ? JSON.parse(row.properties) : row.properties || {},\n      confidence: row.confidence as number,\n      createdAt: new Date(row.created_at as string | number),\n      updatedAt: new Date(row.updated_at as string | number),\n      sourceSessionIds: row.source_session_ids ? JSON.parse(row.source_session_ids as string) : undefined,\n    };\n  }\n  \n  private deserializeEdge(row: Record<string, unknown>): Edge {\n    return {\n      id: row.id as string,\n      type: row.type as string,\n      fromNodeId: row.from_node_id as string,\n      toNodeId: row.to_node_id as string,\n      properties: typeof row.properties === 'string' ? JSON.parse(row.properties) : row.properties || {},\n      confidence: row.confidence as number,\n      createdAt: new Date(row.created_at as string | number),\n      sourceSessionIds: row.source_session_ids ? JSON.parse(row.source_session_ids as string) : undefined,\n    };\n  }\n  \n  private deserializeNodeIndex(row: Record<string, unknown>): NodeIndex {\n    return {\n      indexKey: row.index_key as string,\n      nodeId: row.node_id as string,\n      createdAt: new Date(row.created_at as string | number),\n    };\n  }\n  \n  private deserializeEdgeIndex(row: Record<string, unknown>): EdgeIndex {\n    return {\n      indexKey: row.index_key as string,\n      edgeId: row.edge_id as string,\n      createdAt: new Date(row.created_at as string | number),\n    };\n  }\n  \n  private deserializeSearchIndex(row: Record<string, unknown>): SearchIndex {\n    return {\n      term: row.term as string,\n      nodeId: row.node_id as string,\n      field: row.field as string,\n      weight: row.weight as number,\n    };\n  }\n}","import { BaseAdapter, TransactionContext, DatabaseStats, AdapterConfig } from './base';\nimport type { Node, Edge, NodeIndex, EdgeIndex, SearchIndex, NewNode, NewEdge, NewNodeIndex, NewEdgeIndex, NewSearchIndex } from '../schema';\n\n/**\n * SqlStorage interface - matches the browser's SqlStorage API\n */\ninterface SqlStorage {\n  exec(query: string, ...params: any[]): {\n    toArray(): any[];\n    rowsWritten?: number;\n  };\n}\n\n/**\n * SqlStorage adapter for browser environments\n * Works with browser-based SQL storage implementations\n */\nexport class SqlStorageAdapter extends BaseAdapter {\n  private sql: SqlStorage | null = null;\n\n  constructor(config: AdapterConfig = {}) {\n    super(config);\n  }\n\n  /**\n   * Set the SqlStorage instance\n   * Must be called before using the adapter\n   */\n  setSqlStorage(sql: SqlStorage): void {\n    this.sql = sql;\n  }\n\n  async initialize(): Promise<void> {\n    if (!this.sql) {\n      throw new Error('SqlStorage not set. Call setSqlStorage() first.');\n    }\n\n    try {\n      if (this.config.autoCreate !== false) {\n        await this.createTables();\n      }\n\n      this.log('SqlStorage adapter initialized');\n    } catch (error) {\n      this.error('Failed to initialize SqlStorage adapter', error);\n      throw error;\n    }\n  }\n\n  private async createTables(): Promise<void> {\n    if (!this.sql) throw new Error('SqlStorage not initialized');\n\n    // Create nodes table\n    this.sql.exec(`\n      CREATE TABLE IF NOT EXISTS kg_nodes (\n        id TEXT PRIMARY KEY,\n        type TEXT NOT NULL,\n        label TEXT NOT NULL,\n        properties TEXT NOT NULL DEFAULT '{}',\n        confidence REAL NOT NULL DEFAULT 1.0,\n        created_at INTEGER NOT NULL,\n        updated_at INTEGER NOT NULL,\n        source_session_ids TEXT\n      )\n    `);\n    this.sql.exec(`CREATE INDEX IF NOT EXISTS idx_nodes_type ON kg_nodes(type)`);\n    this.sql.exec(`CREATE INDEX IF NOT EXISTS idx_nodes_label ON kg_nodes(label)`);\n    this.sql.exec(`CREATE INDEX IF NOT EXISTS idx_nodes_created_at ON kg_nodes(created_at)`);\n\n    // Create edges table\n    this.sql.exec(`\n      CREATE TABLE IF NOT EXISTS kg_edges (\n        id TEXT PRIMARY KEY,\n        type TEXT NOT NULL,\n        from_node_id TEXT NOT NULL REFERENCES kg_nodes(id) ON DELETE CASCADE,\n        to_node_id TEXT NOT NULL REFERENCES kg_nodes(id) ON DELETE CASCADE,\n        properties TEXT NOT NULL DEFAULT '{}',\n        confidence REAL NOT NULL DEFAULT 1.0,\n        created_at INTEGER NOT NULL,\n        source_session_ids TEXT\n      )\n    `);\n    this.sql.exec(`CREATE INDEX IF NOT EXISTS idx_edges_type ON kg_edges(type)`);\n    this.sql.exec(`CREATE INDEX IF NOT EXISTS idx_edges_from_node ON kg_edges(from_node_id)`);\n    this.sql.exec(`CREATE INDEX IF NOT EXISTS idx_edges_to_node ON kg_edges(to_node_id)`);\n    this.sql.exec(`CREATE INDEX IF NOT EXISTS idx_edges_from_type ON kg_edges(from_node_id, type)`);\n    this.sql.exec(`CREATE INDEX IF NOT EXISTS idx_edges_to_type ON kg_edges(to_node_id, type)`);\n\n    // Create node indices table\n    this.sql.exec(`\n      CREATE TABLE IF NOT EXISTS kg_node_indices (\n        index_key TEXT NOT NULL,\n        node_id TEXT NOT NULL REFERENCES kg_nodes(id) ON DELETE CASCADE,\n        created_at INTEGER NOT NULL,\n        PRIMARY KEY (index_key, node_id)\n      )\n    `);\n    this.sql.exec(`CREATE INDEX IF NOT EXISTS idx_node_indices_key ON kg_node_indices(index_key)`);\n    this.sql.exec(`CREATE INDEX IF NOT EXISTS idx_node_indices_node ON kg_node_indices(node_id)`);\n\n    // Create edge indices table\n    this.sql.exec(`\n      CREATE TABLE IF NOT EXISTS kg_edge_indices (\n        index_key TEXT NOT NULL,\n        edge_id TEXT NOT NULL REFERENCES kg_edges(id) ON DELETE CASCADE,\n        created_at INTEGER NOT NULL,\n        PRIMARY KEY (index_key, edge_id)\n      )\n    `);\n    this.sql.exec(`CREATE INDEX IF NOT EXISTS idx_edge_indices_key ON kg_edge_indices(index_key)`);\n    this.sql.exec(`CREATE INDEX IF NOT EXISTS idx_edge_indices_edge ON kg_edge_indices(edge_id)`);\n\n    // Create search index table\n    this.sql.exec(`\n      CREATE TABLE IF NOT EXISTS kg_search_index (\n        term TEXT NOT NULL,\n        node_id TEXT NOT NULL REFERENCES kg_nodes(id) ON DELETE CASCADE,\n        field TEXT NOT NULL,\n        weight REAL NOT NULL DEFAULT 1.0,\n        PRIMARY KEY (term, node_id, field)\n      )\n    `);\n    this.sql.exec(`CREATE INDEX IF NOT EXISTS idx_search_term ON kg_search_index(term)`);\n    this.sql.exec(`CREATE INDEX IF NOT EXISTS idx_search_node ON kg_search_index(node_id)`);\n\n    // Create graph metadata table\n    this.sql.exec(`\n      CREATE TABLE IF NOT EXISTS kg_graph_metadata (\n        key TEXT PRIMARY KEY,\n        value TEXT NOT NULL,\n        updated_at INTEGER NOT NULL\n      )\n    `);\n  }\n\n  async execute<T = unknown>(query: string, params: any[] = []): Promise<T[]> {\n    if (!this.sql) throw new Error('SqlStorage not initialized');\n\n    try {\n      const result = this.sql.exec(query, ...params);\n      return result.toArray() as T[];\n    } catch (error) {\n      this.error('Query execution failed', { query, params, error });\n      throw error;\n    }\n  }\n\n  async transaction<T>(fn: (tx: TransactionContext) => Promise<T>): Promise<T> {\n    if (!this.sql) throw new Error('SqlStorage not initialized');\n\n    // SqlStorage doesn't have native transaction support\n    // We'll execute operations directly\n    const tx: TransactionContext = {\n      execute: async <U = unknown>(query: string, params: any[] = []): Promise<U[]> => {\n        return this.execute<U>(query, params);\n      },\n      rollback: async () => {\n        throw new Error('SqlStorage does not support transaction rollback');\n      },\n    };\n\n    try {\n      return await fn(tx);\n    } catch (error) {\n      this.error('Transaction failed', error);\n      throw error;\n    }\n  }\n\n  // Node operations\n  async insertNode(node: NewNode): Promise<Node> {\n    const now = Date.now();\n    const id = node.id || this.generateId();\n    const properties = JSON.stringify(node.properties || {});\n    const sourceSessionIds = node.sourceSessionIds ? JSON.stringify(node.sourceSessionIds) : null;\n\n    const query = `\n      INSERT INTO kg_nodes (id, type, label, properties, confidence, created_at, updated_at, source_session_ids)\n      VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n    `;\n\n    await this.execute(query, [\n      id,\n      node.type,\n      node.label,\n      properties,\n      node.confidence || 1.0,\n      node.createdAt?.getTime() || now,\n      node.updatedAt?.getTime() || now,\n      sourceSessionIds,\n    ]);\n\n    const result = await this.getNode(id);\n    if (!result) throw new Error('Failed to create node');\n    return result;\n  }\n\n  async updateNode(id: string, updates: Partial<NewNode>): Promise<Node | null> {\n    const current = await this.getNode(id);\n    if (!current) return null;\n\n    const setClauses: string[] = [];\n    const params: any[] = [];\n\n    if (updates.type !== undefined) {\n      setClauses.push('type = ?');\n      params.push(updates.type);\n    }\n    if (updates.label !== undefined) {\n      setClauses.push('label = ?');\n      params.push(updates.label);\n    }\n    if (updates.properties !== undefined) {\n      setClauses.push('properties = ?');\n      params.push(JSON.stringify(updates.properties));\n    }\n    if (updates.confidence !== undefined) {\n      setClauses.push('confidence = ?');\n      params.push(updates.confidence);\n    }\n    if (updates.sourceSessionIds !== undefined) {\n      setClauses.push('source_session_ids = ?');\n      params.push(JSON.stringify(updates.sourceSessionIds));\n    }\n\n    setClauses.push('updated_at = ?');\n    params.push(Date.now());\n\n    params.push(id);\n\n    const query = `UPDATE kg_nodes SET ${setClauses.join(', ')} WHERE id = ?`;\n    await this.execute(query, params);\n\n    return this.getNode(id);\n  }\n\n  async deleteNode(id: string): Promise<boolean> {\n    const query = `DELETE FROM kg_nodes WHERE id = ?`;\n    const result = await this.execute(query, [id]);\n    return Array.isArray(result) || result !== undefined;\n  }\n\n  async getNode(id: string): Promise<Node | null> {\n    const query = `SELECT * FROM kg_nodes WHERE id = ? LIMIT 1`;\n    const result = await this.execute<any>(query, [id]);\n    \n    if (!result || result.length === 0) return null;\n    \n    return this.deserializeNode(result[0]);\n  }\n\n  async getNodes(ids: string[]): Promise<Node[]> {\n    if (ids.length === 0) return [];\n\n    const placeholders = ids.map(() => '?').join(',');\n    const query = `SELECT * FROM kg_nodes WHERE id IN (${placeholders})`;\n    const result = await this.execute<any>(query, ids);\n    \n    return result.map((n: any) => this.deserializeNode(n));\n  }\n\n  async queryNodes(conditions: Record<string, any>, limit = 100, offset = 0): Promise<Node[]> {\n    const whereClauses: string[] = [];\n    const params: any[] = [];\n\n    Object.entries(conditions).forEach(([key, value]) => {\n      whereClauses.push(`${key} = ?`);\n      params.push(value);\n    });\n\n    params.push(limit, offset);\n\n    const query = `\n      SELECT * FROM kg_nodes\n      ${whereClauses.length > 0 ? `WHERE ${whereClauses.join(' AND ')}` : ''}\n      LIMIT ? OFFSET ?\n    `;\n\n    const result = await this.execute<any>(query, params);\n    return result.map((n: any) => this.deserializeNode(n));\n  }\n\n  // Edge operations\n  async insertEdge(edge: NewEdge): Promise<Edge> {\n    const now = Date.now();\n    const id = edge.id || this.generateId();\n    const properties = JSON.stringify(edge.properties || {});\n    const sourceSessionIds = edge.sourceSessionIds ? JSON.stringify(edge.sourceSessionIds) : null;\n\n    const query = `\n      INSERT INTO kg_edges (id, type, from_node_id, to_node_id, properties, confidence, created_at, source_session_ids)\n      VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n    `;\n\n    await this.execute(query, [\n      id,\n      edge.type,\n      edge.fromNodeId,\n      edge.toNodeId,\n      properties,\n      edge.confidence || 1.0,\n      edge.createdAt?.getTime() || now,\n      sourceSessionIds,\n    ]);\n\n    const result = await this.getEdge(id);\n    if (!result) throw new Error('Failed to create edge');\n    return result;\n  }\n\n  async updateEdge(id: string, updates: Partial<NewEdge>): Promise<Edge | null> {\n    const current = await this.getEdge(id);\n    if (!current) return null;\n\n    const setClauses: string[] = [];\n    const params: any[] = [];\n\n    if (updates.type !== undefined) {\n      setClauses.push('type = ?');\n      params.push(updates.type);\n    }\n    if (updates.fromNodeId !== undefined) {\n      setClauses.push('from_node_id = ?');\n      params.push(updates.fromNodeId);\n    }\n    if (updates.toNodeId !== undefined) {\n      setClauses.push('to_node_id = ?');\n      params.push(updates.toNodeId);\n    }\n    if (updates.properties !== undefined) {\n      setClauses.push('properties = ?');\n      params.push(JSON.stringify(updates.properties));\n    }\n    if (updates.confidence !== undefined) {\n      setClauses.push('confidence = ?');\n      params.push(updates.confidence);\n    }\n    if (updates.sourceSessionIds !== undefined) {\n      setClauses.push('source_session_ids = ?');\n      params.push(JSON.stringify(updates.sourceSessionIds));\n    }\n\n    params.push(id);\n\n    const query = `UPDATE kg_edges SET ${setClauses.join(', ')} WHERE id = ?`;\n    await this.execute(query, params);\n\n    return this.getEdge(id);\n  }\n\n  async deleteEdge(id: string): Promise<boolean> {\n    const query = `DELETE FROM kg_edges WHERE id = ?`;\n    await this.execute(query, [id]);\n    return true;\n  }\n\n  async getEdge(id: string): Promise<Edge | null> {\n    const query = `SELECT * FROM kg_edges WHERE id = ? LIMIT 1`;\n    const result = await this.execute<any>(query, [id]);\n    \n    if (!result || result.length === 0) return null;\n    \n    return this.deserializeEdge(result[0]);\n  }\n\n  async getEdges(ids: string[]): Promise<Edge[]> {\n    if (ids.length === 0) return [];\n\n    const placeholders = ids.map(() => '?').join(',');\n    const query = `SELECT * FROM kg_edges WHERE id IN (${placeholders})`;\n    const result = await this.execute<any>(query, ids);\n    \n    return result.map((e: any) => this.deserializeEdge(e));\n  }\n\n  async queryEdges(conditions: Record<string, any>, limit = 100, offset = 0): Promise<Edge[]> {\n    const whereClauses: string[] = [];\n    const params: any[] = [];\n\n    Object.entries(conditions).forEach(([key, value]) => {\n      // Convert camelCase to snake_case for database column names\n      const dbKey = key === 'fromNodeId' ? 'from_node_id' : \n                    key === 'toNodeId' ? 'to_node_id' : \n                    key;\n      whereClauses.push(`${dbKey} = ?`);\n      params.push(value);\n    });\n\n    params.push(limit, offset);\n\n    const query = `\n      SELECT * FROM kg_edges\n      ${whereClauses.length > 0 ? `WHERE ${whereClauses.join(' AND ')}` : ''}\n      LIMIT ? OFFSET ?\n    `;\n\n    const result = await this.execute<any>(query, params);\n    return result.map((e: any) => this.deserializeEdge(e));\n  }\n\n  // Index operations\n  async insertNodeIndex(index: NewNodeIndex): Promise<NodeIndex> {\n    const now = Date.now();\n    const query = `\n      INSERT INTO kg_node_indices (index_key, node_id, created_at)\n      VALUES (?, ?, ?)\n    `;\n\n    await this.execute(query, [index.indexKey, index.nodeId, index.createdAt?.getTime() || now]);\n\n    return {\n      ...index,\n      createdAt: index.createdAt || new Date(now),\n    };\n  }\n\n  async deleteNodeIndex(indexKey: string, nodeId?: string): Promise<number> {\n    const query = nodeId\n      ? `DELETE FROM kg_node_indices WHERE index_key = ? AND node_id = ?`\n      : `DELETE FROM kg_node_indices WHERE index_key = ?`;\n    const params = nodeId ? [indexKey, nodeId] : [indexKey];\n\n    const result = await this.execute(query, params);\n    return Array.isArray(result) ? result.length : 0;\n  }\n\n  async getNodeIndices(indexKey: string): Promise<NodeIndex[]> {\n    const query = `SELECT * FROM kg_node_indices WHERE index_key = ?`;\n    const result = await this.execute<any>(query, [indexKey]);\n    \n    return result.map((idx: any) => ({\n      indexKey: idx.index_key,\n      nodeId: idx.node_id,\n      createdAt: new Date(idx.created_at),\n    }));\n  }\n\n  async insertEdgeIndex(index: NewEdgeIndex): Promise<EdgeIndex> {\n    const now = Date.now();\n    const query = `\n      INSERT INTO kg_edge_indices (index_key, edge_id, created_at)\n      VALUES (?, ?, ?)\n    `;\n\n    await this.execute(query, [index.indexKey, index.edgeId, index.createdAt?.getTime() || now]);\n\n    return {\n      ...index,\n      createdAt: index.createdAt || new Date(now),\n    };\n  }\n\n  async deleteEdgeIndex(indexKey: string, edgeId?: string): Promise<number> {\n    const query = edgeId\n      ? `DELETE FROM kg_edge_indices WHERE index_key = ? AND edge_id = ?`\n      : `DELETE FROM kg_edge_indices WHERE index_key = ?`;\n    const params = edgeId ? [indexKey, edgeId] : [indexKey];\n\n    const result = await this.execute(query, params);\n    return Array.isArray(result) ? result.length : 0;\n  }\n\n  async getEdgeIndices(indexKey: string): Promise<EdgeIndex[]> {\n    const query = `SELECT * FROM kg_edge_indices WHERE index_key = ?`;\n    const result = await this.execute<any>(query, [indexKey]);\n    \n    return result.map((idx: any) => ({\n      indexKey: idx.index_key,\n      edgeId: idx.edge_id,\n      createdAt: new Date(idx.created_at),\n    }));\n  }\n\n  // Search operations\n  async insertSearchIndex(index: NewSearchIndex): Promise<SearchIndex> {\n    const query = `\n      INSERT OR REPLACE INTO kg_search_index (term, node_id, field, weight)\n      VALUES (?, ?, ?, ?)\n    `;\n\n    await this.execute(query, [index.term, index.nodeId, index.field, index.weight || 1.0]);\n\n    return {\n      ...index,\n      weight: index.weight || 1.0,\n    };\n  }\n\n  async deleteSearchIndex(nodeId: string): Promise<number> {\n    const query = `DELETE FROM kg_search_index WHERE node_id = ?`;\n    const result = await this.execute(query, [nodeId]);\n    return Array.isArray(result) ? result.length : 0;\n  }\n\n  async searchNodes(term: string, limit = 50): Promise<SearchIndex[]> {\n    const query = `\n      SELECT * FROM kg_search_index\n      WHERE term LIKE ?\n      LIMIT ?\n    `;\n    const result = await this.execute<any>(query, [`%${term}%`, limit]);\n    \n    return result.map((idx: any) => ({\n      term: idx.term,\n      nodeId: idx.node_id,\n      field: idx.field,\n      weight: idx.weight,\n    }));\n  }\n\n  // Batch operations\n  async batchInsertNodes(nodes: NewNode[]): Promise<Node[]> {\n    const results: Node[] = [];\n    \n    for (const node of nodes) {\n      const inserted = await this.insertNode(node);\n      results.push(inserted);\n    }\n    \n    return results;\n  }\n\n  async batchInsertEdges(edges: NewEdge[]): Promise<Edge[]> {\n    const results: Edge[] = [];\n    \n    for (const edge of edges) {\n      const inserted = await this.insertEdge(edge);\n      results.push(inserted);\n    }\n    \n    return results;\n  }\n\n  async batchDeleteNodes(ids: string[]): Promise<number> {\n    if (ids.length === 0) return 0;\n\n    const placeholders = ids.map(() => '?').join(',');\n    const query = `DELETE FROM kg_nodes WHERE id IN (${placeholders})`;\n    const result = await this.execute(query, ids);\n    return Array.isArray(result) ? result.length : ids.length;\n  }\n\n  async batchDeleteEdges(ids: string[]): Promise<number> {\n    if (ids.length === 0) return 0;\n\n    const placeholders = ids.map(() => '?').join(',');\n    const query = `DELETE FROM kg_edges WHERE id IN (${placeholders})`;\n    const result = await this.execute(query, ids);\n    return Array.isArray(result) ? result.length : ids.length;\n  }\n\n  // Maintenance operations\n  async vacuum(): Promise<void> {\n    if (!this.sql) throw new Error('SqlStorage not initialized');\n\n    try {\n      this.sql.exec('VACUUM');\n      this.log('Database vacuumed');\n    } catch {\n      // SqlStorage might not support VACUUM\n      this.log('VACUUM not supported by SqlStorage');\n    }\n  }\n\n  async getStats(): Promise<DatabaseStats> {\n    const nodeCountResult = await this.execute<any>('SELECT COUNT(*) as count FROM kg_nodes');\n    const edgeCountResult = await this.execute<any>('SELECT COUNT(*) as count FROM kg_edges');\n    const indexCountResult = await this.execute<any>('SELECT COUNT(*) as count FROM kg_node_indices');\n\n    return {\n      nodeCount: nodeCountResult[0]?.count || 0,\n      edgeCount: edgeCountResult[0]?.count || 0,\n      indexCount: indexCountResult[0]?.count || 0,\n    };\n  }\n\n  async close(): Promise<void> {\n    this.sql = null;\n    this.log('SqlStorage adapter closed');\n  }\n\n  // Helper methods\n  private generateId(): string {\n    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private deserializeNode(node: any): Node {\n    return {\n      id: node.id,\n      type: node.type,\n      label: node.label,\n      properties: typeof node.properties === 'string' ? JSON.parse(node.properties) : node.properties,\n      confidence: node.confidence,\n      createdAt: new Date(node.created_at),\n      updatedAt: new Date(node.updated_at),\n      sourceSessionIds: node.source_session_ids \n        ? (typeof node.source_session_ids === 'string' ? JSON.parse(node.source_session_ids) : node.source_session_ids)\n        : undefined,\n    };\n  }\n\n  private deserializeEdge(edge: any): Edge {\n    return {\n      id: edge.id,\n      type: edge.type,\n      fromNodeId: edge.from_node_id,\n      toNodeId: edge.to_node_id,\n      properties: typeof edge.properties === 'string' ? JSON.parse(edge.properties) : edge.properties,\n      confidence: edge.confidence,\n      createdAt: new Date(edge.created_at),\n      sourceSessionIds: edge.source_session_ids\n        ? (typeof edge.source_session_ids === 'string' ? JSON.parse(edge.source_session_ids) : edge.source_session_ids)\n        : undefined,\n    };\n  }\n}"],"mappings":"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","names":["import_better_sqlite3","Database","index","nodes","edges","index","nodes","edges","index","nodes","edges"]}