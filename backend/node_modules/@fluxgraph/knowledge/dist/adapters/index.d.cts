import { B as BaseAdapter, A as AdapterConfig, T as TransactionContext, N as NewNode, a as Node, b as NewEdge, E as Edge, c as NewNodeIndex, d as NodeIndex, e as NewEdgeIndex, f as EdgeIndex, g as NewSearchIndex, S as SearchIndex, h as DatabaseStats, D as DatabaseAdapter } from '../base-DQbXAhv3.cjs';
import { D1Database } from '@cloudflare/workers-types';
import 'drizzle-orm/sqlite-core';
import 'drizzle-orm';

/**
 * SQLite adapter implementation using better-sqlite3
 */
declare class SQLiteAdapter extends BaseAdapter {
    private db;
    private drizzle;
    constructor(config?: AdapterConfig);
    initialize(): Promise<void>;
    private createTables;
    execute<T = unknown>(query: string, params?: unknown[]): Promise<T[]>;
    executeUpdate(query: string, params?: unknown[]): Promise<{
        changes: number;
    }>;
    transaction<T>(fn: (tx: TransactionContext) => Promise<T>): Promise<T>;
    insertNode(node: NewNode): Promise<Node>;
    updateNode(id: string, updates: Partial<NewNode>): Promise<Node | null>;
    deleteNode(id: string): Promise<boolean>;
    getNode(id: string): Promise<Node | null>;
    getNodes(ids: string[]): Promise<Node[]>;
    queryNodes(conditions: Record<string, unknown>, limit?: number, offset?: number): Promise<Node[]>;
    insertEdge(edge: NewEdge): Promise<Edge>;
    updateEdge(id: string, updates: Partial<NewEdge>): Promise<Edge | null>;
    deleteEdge(id: string): Promise<boolean>;
    getEdge(id: string): Promise<Edge | null>;
    getEdges(ids: string[]): Promise<Edge[]>;
    queryEdges(conditions: Record<string, unknown>, limit?: number, offset?: number): Promise<Edge[]>;
    insertNodeIndex(index: NewNodeIndex): Promise<NodeIndex>;
    deleteNodeIndex(indexKey: string, nodeId?: string): Promise<number>;
    getNodeIndices(indexKey: string): Promise<NodeIndex[]>;
    insertEdgeIndex(index: NewEdgeIndex): Promise<EdgeIndex>;
    deleteEdgeIndex(indexKey: string, edgeId?: string): Promise<number>;
    getEdgeIndices(indexKey: string): Promise<EdgeIndex[]>;
    insertSearchIndex(index: NewSearchIndex): Promise<SearchIndex>;
    deleteSearchIndex(nodeId: string): Promise<number>;
    searchNodes(term: string, limit?: number): Promise<SearchIndex[]>;
    batchInsertNodes(nodes: NewNode[]): Promise<Node[]>;
    batchInsertEdges(edges: NewEdge[]): Promise<Edge[]>;
    batchDeleteNodes(ids: string[]): Promise<number>;
    batchDeleteEdges(ids: string[]): Promise<number>;
    vacuum(): Promise<void>;
    getStats(): Promise<DatabaseStats>;
    close(): Promise<void>;
    private deserializeNode;
    private deserializeEdge;
}

/**
 * Cloudflare D1 adapter implementation
 * Uses raw SQL queries for compatibility with D1 in Durable Objects
 */
declare class D1Adapter extends BaseAdapter {
    private db;
    constructor(config: AdapterConfig & {
        database?: D1Database;
    });
    setDatabase(db: D1Database): void;
    initialize(): Promise<void>;
    private createTables;
    execute<T = unknown>(query: string, params?: unknown[]): Promise<T[]>;
    transaction<T>(fn: (tx: TransactionContext) => Promise<T>): Promise<T>;
    insertNode(node: NewNode): Promise<Node>;
    updateNode(id: string, updates: Partial<NewNode>): Promise<Node | null>;
    deleteNode(id: string): Promise<boolean>;
    getNode(id: string): Promise<Node | null>;
    getNodes(ids: string[]): Promise<Node[]>;
    queryNodes(conditions: Record<string, unknown>, limit?: number, offset?: number): Promise<Node[]>;
    insertEdge(edge: NewEdge): Promise<Edge>;
    updateEdge(id: string, updates: Partial<NewEdge>): Promise<Edge | null>;
    deleteEdge(id: string): Promise<boolean>;
    getEdge(id: string): Promise<Edge | null>;
    getEdges(ids: string[]): Promise<Edge[]>;
    queryEdges(conditions: Record<string, unknown>, limit?: number, offset?: number): Promise<Edge[]>;
    insertNodeIndex(index: NewNodeIndex): Promise<NodeIndex>;
    deleteNodeIndex(indexKey: string, nodeId?: string): Promise<number>;
    getNodeIndices(indexKey: string): Promise<NodeIndex[]>;
    insertEdgeIndex(index: NewEdgeIndex): Promise<EdgeIndex>;
    deleteEdgeIndex(indexKey: string, edgeId?: string): Promise<number>;
    getEdgeIndices(indexKey: string): Promise<EdgeIndex[]>;
    insertSearchIndex(index: NewSearchIndex): Promise<SearchIndex>;
    deleteSearchIndex(nodeId: string): Promise<number>;
    searchNodes(term: string, limit?: number): Promise<SearchIndex[]>;
    batchInsertNodes(nodes: NewNode[]): Promise<Node[]>;
    batchInsertEdges(edges: NewEdge[]): Promise<Edge[]>;
    batchDeleteNodes(ids: string[]): Promise<number>;
    batchDeleteEdges(ids: string[]): Promise<number>;
    vacuum(): Promise<void>;
    getStats(): Promise<DatabaseStats>;
    close(): Promise<void>;
    private deserializeNode;
    private deserializeEdge;
    private deserializeNodeIndex;
    private deserializeEdgeIndex;
    private deserializeSearchIndex;
}

/**
 * SqlStorage interface - matches the browser's SqlStorage API
 */
interface SqlStorage {
    exec(query: string, ...params: any[]): {
        toArray(): any[];
        rowsWritten?: number;
    };
}
/**
 * SqlStorage adapter for browser environments
 * Works with browser-based SQL storage implementations
 */
declare class SqlStorageAdapter extends BaseAdapter {
    private sql;
    constructor(config?: AdapterConfig);
    /**
     * Set the SqlStorage instance
     * Must be called before using the adapter
     */
    setSqlStorage(sql: SqlStorage): void;
    initialize(): Promise<void>;
    private createTables;
    execute<T = unknown>(query: string, params?: any[]): Promise<T[]>;
    transaction<T>(fn: (tx: TransactionContext) => Promise<T>): Promise<T>;
    insertNode(node: NewNode): Promise<Node>;
    updateNode(id: string, updates: Partial<NewNode>): Promise<Node | null>;
    deleteNode(id: string): Promise<boolean>;
    getNode(id: string): Promise<Node | null>;
    getNodes(ids: string[]): Promise<Node[]>;
    queryNodes(conditions: Record<string, any>, limit?: number, offset?: number): Promise<Node[]>;
    insertEdge(edge: NewEdge): Promise<Edge>;
    updateEdge(id: string, updates: Partial<NewEdge>): Promise<Edge | null>;
    deleteEdge(id: string): Promise<boolean>;
    getEdge(id: string): Promise<Edge | null>;
    getEdges(ids: string[]): Promise<Edge[]>;
    queryEdges(conditions: Record<string, any>, limit?: number, offset?: number): Promise<Edge[]>;
    insertNodeIndex(index: NewNodeIndex): Promise<NodeIndex>;
    deleteNodeIndex(indexKey: string, nodeId?: string): Promise<number>;
    getNodeIndices(indexKey: string): Promise<NodeIndex[]>;
    insertEdgeIndex(index: NewEdgeIndex): Promise<EdgeIndex>;
    deleteEdgeIndex(indexKey: string, edgeId?: string): Promise<number>;
    getEdgeIndices(indexKey: string): Promise<EdgeIndex[]>;
    insertSearchIndex(index: NewSearchIndex): Promise<SearchIndex>;
    deleteSearchIndex(nodeId: string): Promise<number>;
    searchNodes(term: string, limit?: number): Promise<SearchIndex[]>;
    batchInsertNodes(nodes: NewNode[]): Promise<Node[]>;
    batchInsertEdges(edges: NewEdge[]): Promise<Edge[]>;
    batchDeleteNodes(ids: string[]): Promise<number>;
    batchDeleteEdges(ids: string[]): Promise<number>;
    vacuum(): Promise<void>;
    getStats(): Promise<DatabaseStats>;
    close(): Promise<void>;
    private generateId;
    private deserializeNode;
    private deserializeEdge;
}

declare function createAdapter(type: 'sqlite' | 'd1' | 'libsql' | 'sql-storage', config?: AdapterConfig): Promise<DatabaseAdapter>;

export { AdapterConfig, BaseAdapter, D1Adapter, DatabaseAdapter, DatabaseStats, SQLiteAdapter, SqlStorageAdapter, TransactionContext, createAdapter };
