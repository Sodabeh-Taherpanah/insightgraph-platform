import { K as KnowledgeGraph, E as ExtractedNodeData, a as ExtractedEdgeData, b as ExtractedKnowledge, Q as QueryResult } from './KnowledgeGraph-Bf7WVoAx.js';
export { B as BatchResult, C as CommonEdgeType, h as EdgeOptions, c as EdgeType, G as GraphStats, e as KnowledgeEdge, d as KnowledgeNode, M as Migration, g as NodeOptions, N as NodeType, P as Path, f as QueryOptions, S as SearchOptions, T as TraversalOptions } from './KnowledgeGraph-Bf7WVoAx.js';
export { D1Adapter, SQLiteAdapter, SqlStorageAdapter, createAdapter } from './adapters/index.js';
export { A as AdapterConfig, B as BaseAdapter, D as DatabaseAdapter, i as schema } from './base-DQbXAhv3.js';
import '@cloudflare/workers-types';
import 'drizzle-orm/sqlite-core';
import 'drizzle-orm';

/**
 * Options for knowledge extraction
 */
interface ExtractionOptions {
    minConfidence?: number;
    extractEntities?: boolean;
    extractRelationships?: boolean;
    extractTopics?: boolean;
    extractSentiment?: boolean;
    mergeStrategy?: 'replace' | 'merge' | 'skip';
    sessionId?: string;
}
/**
 * Entity pattern for extraction
 */
interface EntityPattern {
    pattern: RegExp;
    type: string;
    extractor?: (match: RegExpMatchArray) => Partial<ExtractedNodeData>;
}
/**
 * Relationship pattern for extraction
 */
interface RelationshipPattern {
    pattern: RegExp;
    type: string;
    extractor?: (match: RegExpMatchArray, nodes: Map<string, ExtractedNodeData>) => Partial<ExtractedEdgeData>;
}
/**
 * Knowledge extraction service
 */
declare class KnowledgeExtractor {
    private graph;
    private entityPatterns;
    private relationshipPatterns;
    constructor(graph: KnowledgeGraph);
    /**
     * Setup default extraction patterns
     */
    private setupDefaultPatterns;
    /**
     * Add custom entity pattern
     */
    addEntityPattern(pattern: EntityPattern): void;
    /**
     * Add custom relationship pattern
     */
    addRelationshipPattern(pattern: RelationshipPattern): void;
    /**
     * Extract knowledge from text
     */
    extractFromText(text: string, options?: ExtractionOptions): Promise<ExtractedKnowledge>;
    /**
     * Extract knowledge from structured data
     */
    extractFromStructured(data: Record<string, any>, options?: ExtractionOptions): Promise<ExtractedKnowledge>;
    /**
     * Process extracted knowledge and add to graph
     */
    processExtractedKnowledge(extraction: ExtractedKnowledge, options?: ExtractionOptions): Promise<{
        nodesAdded: number;
        edgesAdded: number;
    }>;
    /**
     * Extract knowledge from conversation/chat messages
     */
    extractFromConversation(messages: Array<{
        role: string;
        content: string;
    }>, options?: ExtractionOptions): Promise<ExtractedKnowledge>;
    /**
     * Infer node type from key and value
     */
    private inferNodeType;
    /**
     * Calculate overall confidence score
     */
    private calculateOverallConfidence;
}
declare function extractFromText(graph: KnowledgeGraph, text: string, options?: ExtractionOptions): Promise<ExtractedKnowledge>;
declare function extractFromConversation(graph: KnowledgeGraph, messages: Array<{
    role: string;
    content: string;
}>, options?: ExtractionOptions): Promise<ExtractedKnowledge>;
declare function processExtractedKnowledge(graph: KnowledgeGraph, extraction: ExtractedKnowledge, options?: ExtractionOptions): Promise<{
    nodesAdded: number;
    edgesAdded: number;
}>;

/**
 * Mermaid-based visualization for Knowledge Graphs
 *
 * Generates Mermaid diagram syntax from knowledge graph data,
 * which can be rendered using any Mermaid-compatible renderer.
 */

interface MermaidVisualizationOptions {
    direction?: 'TB' | 'TD' | 'BT' | 'RL' | 'LR';
    theme?: 'default' | 'dark' | 'forest' | 'neutral';
    maxNodes?: number;
    maxEdges?: number;
    includeProperties?: boolean;
    nodeTypeStyles?: Record<string, string>;
    edgeTypeStyles?: Record<string, string>;
}
interface MermaidDiagram {
    type: 'graph' | 'flowchart';
    direction: string;
    content: string;
    nodeCount: number;
    edgeCount: number;
}
/**
 * Generates Mermaid diagram syntax from knowledge graph data
 */
declare class MermaidGraphVisualizer {
    private graph;
    constructor(graph: KnowledgeGraph);
    /**
     * Generate a Mermaid diagram from a query result
     */
    generateFromQueryResult(queryResult: QueryResult, options?: MermaidVisualizationOptions): MermaidDiagram;
    /**
     * Generate a Mermaid diagram for a specific node and its neighborhood
     */
    generateFromNode(nodeId: string, depth?: number, options?: MermaidVisualizationOptions): Promise<MermaidDiagram>;
    /**
     * Generate a Mermaid diagram from a search query
     */
    generateFromSearch(query: string, options?: MermaidVisualizationOptions): Promise<MermaidDiagram>;
    /**
     * Generate a Mermaid diagram for specific node types
     */
    generateFromNodeTypes(nodeTypes: string[], options?: MermaidVisualizationOptions): Promise<MermaidDiagram>;
    /**
     * Sanitize node ID for Mermaid syntax
     */
    private sanitizeId;
    /**
     * Format node label with optional properties
     */
    private formatNodeLabel;
    /**
     * Format edge label with optional properties
     */
    private formatEdgeLabel;
    /**
     * Format property value for display
     */
    private formatValue;
    /**
     * Escape special characters in labels
     */
    private escapeLabel;
    /**
     * Get node style based on type
     */
    private getNodeStyle;
}
/**
 * Utility functions for working with Mermaid diagrams
 */
declare class MermaidUtils {
    /**
     * Wrap Mermaid diagram in HTML for rendering
     */
    static wrapInHtml(diagram: MermaidDiagram, options?: {
        title?: string;
        theme?: string;
    }): string;
    /**
     * Generate a URL for rendering with Mermaid Live Editor
     */
    static generateLiveEditorUrl(diagram: MermaidDiagram): string;
    /**
     * Convert diagram to Markdown with Mermaid code block
     */
    static toMarkdown(diagram: MermaidDiagram, title?: string): string;
}

declare const PerformanceUtils: {
    isSuitableForRealTime: (nodeCount: number, _edgeCount: number) => boolean;
    getRecommendedBackend: (_nodeCount: number, _edgeCount: number) => "mermaid";
};
declare const ColorUtils: {
    generateNodeColorPalette: (types: string[]) => Record<string, string>;
    generateEdgeColorPalette: (types: string[]) => Record<string, string>;
};
declare const LayoutUtils: {
    getLayoutOptionsForGraphSize: (nodeCount: number, _edgeCount: number) => {
        layout: "TD";
    } | {
        layout: "LR";
    } | {
        layout: "TB";
    };
    calculateOptimalNodeSizes: (nodesByType: Record<string, number>, _total: number) => Record<string, number>;
    calculateOptimalEdgeWidths: (edgesByType: Record<string, number>, _total: number) => Record<string, number>;
};
type VisualizationBackend = 'mermaid';

export { ColorUtils, ExtractedEdgeData, ExtractedKnowledge, ExtractedNodeData, type MermaidDiagram as GraphSnapshot, MermaidGraphVisualizer as GraphVisualizationManager, KnowledgeExtractor, KnowledgeGraph, LayoutUtils, type MermaidDiagram, MermaidGraphVisualizer, MermaidUtils, type MermaidVisualizationOptions, PerformanceUtils, QueryResult, type VisualizationBackend, extractFromConversation, extractFromText, processExtractedKnowledge };
