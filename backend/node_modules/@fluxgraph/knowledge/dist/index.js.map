{"version":3,"sources":["../src/index.ts","../src/core/KnowledgeGraph.ts","../src/types/index.ts","../src/adapters/base.ts","../src/adapters/sqlite.ts","../src/schema/index.ts","../src/adapters/d1.ts","../src/adapters/sql-storage.ts","../src/adapters/index.ts","../src/extraction/index.ts","../src/visualization/index.ts"],"sourcesContent":["// Core exports\nexport { KnowledgeGraph } from './core/KnowledgeGraph';\n\n// Type exports\nexport * from './types';\nexport { CommonEdgeType } from './types';\n\n// Adapter exports\nexport type { DatabaseAdapter, AdapterConfig } from './adapters';\nexport { SQLiteAdapter, D1Adapter, SqlStorageAdapter, createAdapter, BaseAdapter } from './adapters';\n\n// Extraction exports\nexport { KnowledgeExtractor, extractFromText, extractFromConversation, processExtractedKnowledge } from './extraction';\n\n// Visualization exports\nexport * from './visualization';\n\n// Schema exports (for advanced users)\nexport * as schema from './schema';\n","import { DatabaseAdapter } from '../adapters/base';\nimport {\n  KnowledgeNode,\n  KnowledgeEdge,\n  NodeType,\n  EdgeType,\n  QueryResult,\n  QueryOptions,\n  NodeOptions,\n  EdgeOptions,\n  TraversalOptions,\n  Path,\n  GraphStats,\n  SearchOptions,\n  BatchResult,\n} from '../types';\nimport type { NewNode, NewEdge } from '../schema';\n\n/**\n * Main KnowledgeGraph class that provides high-level graph operations\n */\nexport class KnowledgeGraph<TNodeType extends string = string> {\n  private adapter: DatabaseAdapter;\n  private initialized = false;\n\n  constructor(adapter: DatabaseAdapter) {\n    this.adapter = adapter;\n  }\n\n  /**\n   * Initialize the knowledge graph\n   */\n  async initialize(): Promise<void> {\n    if (this.initialized) return;\n\n    await this.adapter.initialize();\n    this.initialized = true;\n  }\n\n  /**\n   * Ensure the graph is initialized\n   */\n  private async ensureInitialized(): Promise<void> {\n    if (!this.initialized) {\n      await this.initialize();\n    }\n  }\n\n  // ============ Node Operations ============\n\n  /**\n   * Add a new node to the graph\n   */\n  async addNode(options: NodeOptions<TNodeType>): Promise<KnowledgeNode> {\n    await this.ensureInitialized();\n\n    const id = crypto.randomUUID();\n    const now = new Date();\n\n    const newNode: NewNode = {\n      id,\n      type: options.type,\n      label: options.label,\n      properties: JSON.stringify(options.properties || {}),\n      confidence: options.confidence || 1.0,\n      createdAt: now,\n      updatedAt: now,\n      sourceSessionIds: options.sourceSessionId ? JSON.stringify([options.sourceSessionId]) : undefined,\n    };\n\n    const node = await this.adapter.insertNode(newNode);\n\n    // Add to search index\n    await this.indexNodeForSearch(node);\n\n    // Add to type index\n    await this.adapter.insertNodeIndex({\n      indexKey: `type:${node.type}`,\n      nodeId: node.id,\n      createdAt: now,\n    });\n\n    return this.normalizeNode(node);\n  }\n\n  /**\n   * Update an existing node\n   */\n  async updateNode(nodeId: string, updates: Partial<NodeOptions<TNodeType>>, mergeProperties = true): Promise<KnowledgeNode | null> {\n    await this.ensureInitialized();\n\n    const existingNode = await this.adapter.getNode(nodeId);\n    if (!existingNode) return null;\n\n    const existingProperties = existingNode.properties as unknown as Record<string, any>;\n    const properties = mergeProperties && updates.properties ? { ...existingProperties, ...updates.properties } : updates.properties || existingProperties;\n\n    const nodeUpdates: Partial<NewNode> = {\n      type: updates.type,\n      label: updates.label,\n      properties: JSON.stringify(properties),\n      confidence: updates.confidence,\n      updatedAt: new Date(),\n    };\n\n    if (updates.sourceSessionId) {\n      const existingSessionIds = Array.isArray(existingNode.sourceSessionIds) ? (existingNode.sourceSessionIds as string[]) : [];\n      if (!existingSessionIds.includes(updates.sourceSessionId)) {\n        existingSessionIds.push(updates.sourceSessionId);\n        nodeUpdates.sourceSessionIds = JSON.stringify(existingSessionIds);\n      }\n    }\n\n    const updatedNode = await this.adapter.updateNode(nodeId, nodeUpdates);\n    if (!updatedNode) return null;\n\n    // Update search index\n    await this.adapter.deleteSearchIndex(nodeId);\n    await this.indexNodeForSearch(updatedNode);\n\n    return this.normalizeNode(updatedNode);\n  }\n\n  /**\n   * Delete a node and all its edges\n   */\n  async deleteNode(nodeId: string): Promise<boolean> {\n    await this.ensureInitialized();\n\n    // Edges are cascade deleted via foreign key constraints\n    return await this.adapter.deleteNode(nodeId);\n  }\n\n  /**\n   * Get a node by ID\n   */\n  async getNode(nodeId: string): Promise<KnowledgeNode | null> {\n    await this.ensureInitialized();\n\n    const node = await this.adapter.getNode(nodeId);\n    return node ? this.normalizeNode(node) : null;\n  }\n\n  /**\n   * Find nodes by label (exact or partial match)\n   */\n  async findNodesByLabel(label: string, exact = false): Promise<KnowledgeNode[]> {\n    await this.ensureInitialized();\n\n    if (exact) {\n      const nodes = await this.adapter.queryNodes({ label }, 100);\n      return nodes.map((n) => this.normalizeNode(n));\n    }\n\n    // Use search index for partial matching\n    const searchResults = await this.adapter.searchNodes(label.toLowerCase());\n    const nodeIds = [...new Set(searchResults.map((r) => r.nodeId))];\n\n    if (nodeIds.length === 0) return [];\n\n    const nodes = await this.adapter.getNodes(nodeIds);\n    return nodes.map((n) => this.normalizeNode(n));\n  }\n\n  // ============ Edge Operations ============\n\n  /**\n   * Add an edge between two nodes\n   */\n  async addEdge(options: EdgeOptions): Promise<KnowledgeEdge> {\n    await this.ensureInitialized();\n\n    // Verify both nodes exist\n    const [fromNode, toNode] = await Promise.all([this.adapter.getNode(options.fromNodeId), this.adapter.getNode(options.toNodeId)]);\n\n    if (!fromNode) {\n      throw new Error(`From node ${options.fromNodeId} does not exist`);\n    }\n    if (!toNode) {\n      throw new Error(`To node ${options.toNodeId} does not exist`);\n    }\n\n    const id = crypto.randomUUID();\n    const now = new Date();\n\n    const newEdge: NewEdge = {\n      id,\n      type: options.type,\n      fromNodeId: options.fromNodeId,\n      toNodeId: options.toNodeId,\n      properties: JSON.stringify(options.properties || {}),\n      confidence: options.confidence || 1.0,\n      createdAt: now,\n      sourceSessionIds: options.sourceSessionId ? JSON.stringify([options.sourceSessionId]) : undefined,\n    };\n\n    const edge = await this.adapter.insertEdge(newEdge);\n\n    // Add to indices\n    await Promise.all([\n      this.adapter.insertEdgeIndex({\n        indexKey: `from:${options.fromNodeId}:${options.type}`,\n        edgeId: id,\n        createdAt: now,\n      }),\n      this.adapter.insertEdgeIndex({\n        indexKey: `to:${options.toNodeId}:${options.type}`,\n        edgeId: id,\n        createdAt: now,\n      }),\n      this.adapter.insertEdgeIndex({\n        indexKey: `type:${options.type}`,\n        edgeId: id,\n        createdAt: now,\n      }),\n    ]);\n\n    // Add bidirectional edge if requested\n    if (options.bidirectional) {\n      await this.addEdge({\n        ...options,\n        fromNodeId: options.toNodeId,\n        toNodeId: options.fromNodeId,\n        bidirectional: false, // Prevent infinite recursion\n      });\n    }\n\n    return this.normalizeEdge(edge);\n  }\n\n  /**\n   * Delete an edge\n   */\n  async deleteEdge(edgeId: string): Promise<boolean> {\n    await this.ensureInitialized();\n    return await this.adapter.deleteEdge(edgeId);\n  }\n\n  /**\n   * Get edges between two nodes\n   */\n  async getEdgesBetween(fromNodeId: string, toNodeId: string, edgeType?: EdgeType | string): Promise<KnowledgeEdge[]> {\n    await this.ensureInitialized();\n\n    const conditions: Record<string, any> = {\n      fromNodeId: fromNodeId,\n      toNodeId: toNodeId,\n    };\n\n    if (edgeType) {\n      conditions.type = edgeType;\n    }\n\n    const edges = await this.adapter.queryEdges(conditions);\n    return edges.map((e) => this.normalizeEdge(e));\n  }\n\n  // ============ Query Operations ============\n\n  /**\n   * Query nodes by type\n   */\n  async queryByType(nodeType: NodeType | string, options?: QueryOptions): Promise<QueryResult> {\n    await this.ensureInitialized();\n\n    const nodes = await this.adapter.queryNodes({ type: nodeType }, options?.limit || 100, options?.offset || 0);\n\n    const edges: KnowledgeEdge[] = [];\n\n    if (options?.includeEdges && nodes.length > 0) {\n      const nodeIds = nodes.map((n) => n.id);\n      const edgeResults = await Promise.all([this.adapter.queryEdges({ fromNodeId: nodeIds[0] }), this.adapter.queryEdges({ toNodeId: nodeIds[0] })]);\n\n      edges.push(...edgeResults.flat().map((e) => this.normalizeEdge(e)));\n    }\n\n    return {\n      nodes: nodes.map((n) => this.normalizeNode(n)),\n      edges,\n      relevanceScore: 1.0,\n    };\n  }\n\n  /**\n   * Query related nodes starting from a given node\n   */\n  async queryRelated(nodeId: string, options?: QueryOptions): Promise<QueryResult> {\n    await this.ensureInitialized();\n\n    const startNode = await this.adapter.getNode(nodeId);\n    if (!startNode) {\n      return { nodes: [], edges: [], relevanceScore: 0 };\n    }\n\n    const visitedNodes = new Map<string, KnowledgeNode>();\n    const visitedEdges = new Map<string, KnowledgeEdge>();\n\n    visitedNodes.set(nodeId, this.normalizeNode(startNode));\n\n    await this.traverseGraph(nodeId, options?.depth || 1, options?.direction || 'both', options?.edgeTypes, visitedNodes, visitedEdges);\n\n    return {\n      nodes: Array.from(visitedNodes.values()),\n      edges: Array.from(visitedEdges.values()),\n      relevanceScore: this.calculateRelevance(visitedNodes.size, visitedEdges.size),\n    };\n  }\n\n  /**\n   * Search nodes using text query\n   */\n  async search(options: SearchOptions): Promise<QueryResult> {\n    await this.ensureInitialized();\n\n    const searchTerms = options.query.toLowerCase().split(/\\s+/);\n    const nodeScores = new Map<string, number>();\n\n    // Search for each term\n    for (const term of searchTerms) {\n      const results = await this.adapter.searchNodes(term, options.limit || 50);\n\n      for (const result of results) {\n        const currentScore = nodeScores.get(result.nodeId) || 0;\n        nodeScores.set(result.nodeId, currentScore + result.weight);\n      }\n    }\n\n    // Filter by minimum score if specified\n    const minScore = options.minScore || 0;\n    const qualifiedNodeIds = Array.from(nodeScores.entries())\n      .filter(([_, score]) => score >= minScore)\n      .sort((a, b) => b[1] - a[1])\n      .slice(0, options.limit || 50)\n      .map(([id]) => id);\n\n    if (qualifiedNodeIds.length === 0) {\n      return { nodes: [], edges: [], relevanceScore: 0 };\n    }\n\n    const nodes = await this.adapter.getNodes(qualifiedNodeIds);\n\n    // Filter by node types if specified\n    const filteredNodes = options.nodeTypes ? nodes.filter((n) => options.nodeTypes!.includes(n.type)) : nodes;\n\n    return {\n      nodes: filteredNodes.map((n) => this.normalizeNode(n)),\n      edges: [],\n      relevanceScore: qualifiedNodeIds[0] ? nodeScores.get(qualifiedNodeIds[0]) || 0 : 0,\n    };\n  }\n\n  // ============ Graph Traversal ============\n\n  /**\n   * Traverse the graph from a starting node\n   */\n  async traverse(options: TraversalOptions): Promise<QueryResult> {\n    await this.ensureInitialized();\n\n    const visitedNodes = new Map<string, KnowledgeNode>();\n    const visitedEdges = new Map<string, KnowledgeEdge>();\n    const queue: Array<{ nodeId: string; depth: number }> = [{ nodeId: options.startNodeId, depth: 0 }];\n    const visited = new Set<string>();\n\n    while (queue.length > 0) {\n      const { nodeId, depth } = queue.shift()!;\n\n      if (visited.has(nodeId) && options.visitOnce !== false) continue;\n      if (depth > (options.maxDepth || Infinity)) continue;\n\n      visited.add(nodeId);\n\n      const node = await this.adapter.getNode(nodeId);\n      if (!node) continue;\n\n      const normalizedNode = this.normalizeNode(node);\n\n      if (!options.nodeFilter || options.nodeFilter(normalizedNode)) {\n        visitedNodes.set(nodeId, normalizedNode);\n      }\n\n      // Get edges based on direction\n      const edges: KnowledgeEdge[] = [];\n\n      if (options.direction === 'out' || options.direction === 'both') {\n        const outEdges = await this.adapter.queryEdges({ from_node_id: nodeId });\n        edges.push(...outEdges.map((e) => this.normalizeEdge(e)));\n      }\n\n      if (options.direction === 'in' || options.direction === 'both') {\n        const inEdges = await this.adapter.queryEdges({ to_node_id: nodeId });\n        edges.push(...inEdges.map((e) => this.normalizeEdge(e)));\n      }\n\n      for (const edge of edges) {\n        if (options.edgeTypes && !options.edgeTypes.includes(edge.type)) continue;\n        if (options.edgeFilter && !options.edgeFilter(edge)) continue;\n\n        visitedEdges.set(edge.id, edge);\n\n        const nextNodeId = edge.fromNodeId === nodeId ? edge.toNodeId : edge.fromNodeId;\n        if (!visited.has(nextNodeId) || options.visitOnce === false) {\n          queue.push({ nodeId: nextNodeId, depth: depth + 1 });\n        }\n      }\n    }\n\n    return {\n      nodes: Array.from(visitedNodes.values()),\n      edges: Array.from(visitedEdges.values()),\n      relevanceScore: 1.0,\n    };\n  }\n\n  /**\n   * Find shortest path between two nodes\n   */\n  async findShortestPath(fromNodeId: string, toNodeId: string, options?: { edgeTypes?: (EdgeType | string)[] }): Promise<Path | null> {\n    await this.ensureInitialized();\n\n    const queue: Array<{ nodeId: string; path: string[]; edges: string[] }> = [{ nodeId: fromNodeId, path: [fromNodeId], edges: [] }];\n    const visited = new Set<string>();\n\n    while (queue.length > 0) {\n      const { nodeId, path, edges } = queue.shift()!;\n\n      if (nodeId === toNodeId) {\n        // Found the target node\n        const nodes = await this.adapter.getNodes(path);\n        const edgeObjects = edges.length > 0 ? await this.adapter.getEdges(edges) : [];\n\n        return {\n          nodes: nodes.map((n) => this.normalizeNode(n)),\n          edges: edgeObjects.map((e) => this.normalizeEdge(e)),\n          length: path.length - 1,\n        };\n      }\n\n      if (visited.has(nodeId)) continue;\n      visited.add(nodeId);\n\n      // Get all outgoing edges\n      const outEdges = await this.adapter.queryEdges({ fromNodeId: nodeId });\n\n      for (const edge of outEdges) {\n        if (options?.edgeTypes && !options.edgeTypes.includes(edge.type)) continue;\n\n        const nextNodeId = edge.toNodeId;\n        if (!visited.has(nextNodeId)) {\n          queue.push({\n            nodeId: nextNodeId,\n            path: [...path, nextNodeId],\n            edges: [...edges, edge.id],\n          });\n        }\n      }\n    }\n\n    return null; // No path found\n  }\n\n  // ============ Statistics ============\n\n  /**\n   * Get graph statistics\n   */\n  async getStats(): Promise<GraphStats> {\n    await this.ensureInitialized();\n\n    const dbStats = await this.adapter.getStats();\n\n    // Count nodes and edges by type\n    const nodeTypes = await this.execute<{ type: string; count: number }>('SELECT type, COUNT(*) as count FROM kg_nodes GROUP BY type');\n\n    const edgeTypes = await this.execute<{ type: string; count: number }>('SELECT type, COUNT(*) as count FROM kg_edges GROUP BY type');\n\n    const nodesByType: Record<string, number> = {};\n    for (const { type, count } of nodeTypes) {\n      nodesByType[type] = count;\n    }\n\n    const edgesByType: Record<string, number> = {};\n    for (const { type, count } of edgeTypes) {\n      edgesByType[type] = count;\n    }\n\n    // Calculate average degree\n    const averageDegree = dbStats.nodeCount > 0 ? (dbStats.edgeCount * 2) / dbStats.nodeCount : 0;\n\n    // Calculate density (actual edges / possible edges)\n    const possibleEdges = dbStats.nodeCount * (dbStats.nodeCount - 1);\n    const density = possibleEdges > 0 ? dbStats.edgeCount / possibleEdges : 0;\n\n    return {\n      nodeCount: dbStats.nodeCount,\n      edgeCount: dbStats.edgeCount,\n      nodesByType,\n      edgesByType,\n      averageDegree,\n      density,\n      lastUpdated: new Date(),\n    };\n  }\n\n  // ============ Batch Operations ============\n\n  /**\n   * Batch insert nodes\n   */\n  async batchAddNodes(nodes: NodeOptions<TNodeType>[]): Promise<BatchResult> {\n    await this.ensureInitialized();\n\n    const successful: string[] = [];\n    const errors: Array<{ item: any; error: Error }> = [];\n\n    for (const nodeOptions of nodes) {\n      try {\n        const node = await this.addNode(nodeOptions);\n        successful.push(node.id);\n      } catch (error) {\n        errors.push({ item: nodeOptions, error: error as Error });\n      }\n    }\n\n    return {\n      successful: successful.length,\n      failed: errors.length,\n      errors: errors.length > 0 ? errors : undefined,\n    };\n  }\n\n  /**\n   * Batch insert edges\n   */\n  async batchAddEdges(edges: EdgeOptions[]): Promise<BatchResult> {\n    await this.ensureInitialized();\n\n    const successful: string[] = [];\n    const errors: Array<{ item: any; error: Error }> = [];\n\n    for (const edgeOptions of edges) {\n      try {\n        const edge = await this.addEdge(edgeOptions);\n        successful.push(edge.id);\n      } catch (error) {\n        errors.push({ item: edgeOptions, error: error as Error });\n      }\n    }\n\n    return {\n      successful: successful.length,\n      failed: errors.length,\n      errors: errors.length > 0 ? errors : undefined,\n    };\n  }\n\n  // ============ Maintenance ============\n\n  /**\n   * Vacuum the database to reclaim space\n   */\n  async vacuum(): Promise<void> {\n    await this.ensureInitialized();\n    await this.adapter.vacuum();\n  }\n\n  /**\n   * Close the database connection\n   */\n  async close(): Promise<void> {\n    await this.adapter.close();\n    this.initialized = false;\n  }\n\n  // ============ Helper Methods ============\n\n  /**\n   * Execute raw SQL query (for advanced use cases)\n   */\n  private async execute<T>(query: string, params: any[] = []): Promise<T[]> {\n    return await this.adapter.execute<T>(query, params);\n  }\n\n  /**\n   * Normalize a node from database format\n   */\n  private normalizeNode(node: any): KnowledgeNode {\n    return {\n      id: node.id,\n      type: node.type,\n      label: node.label,\n      properties: typeof node.properties === 'string' ? JSON.parse(node.properties) : node.properties,\n      confidence: node.confidence,\n      createdAt: node.createdAt instanceof Date ? node.createdAt : new Date(node.createdAt),\n      updatedAt: node.updatedAt instanceof Date ? node.updatedAt : new Date(node.updatedAt),\n      sourceSessionIds: node.sourceSessionIds ? (typeof node.sourceSessionIds === 'string' ? JSON.parse(node.sourceSessionIds) : node.sourceSessionIds) : undefined,\n    };\n  }\n\n  /**\n   * Normalize an edge from database format\n   */\n  private normalizeEdge(edge: any): KnowledgeEdge {\n    return {\n      id: edge.id,\n      type: edge.type,\n      fromNodeId: edge.fromNodeId,\n      toNodeId: edge.toNodeId,\n      properties: typeof edge.properties === 'string' ? JSON.parse(edge.properties) : edge.properties,\n      confidence: edge.confidence,\n      createdAt: edge.createdAt instanceof Date ? edge.createdAt : new Date(edge.createdAt),\n      sourceSessionIds: edge.sourceSessionIds ? (typeof edge.sourceSessionIds === 'string' ? JSON.parse(edge.sourceSessionIds) : edge.sourceSessionIds) : undefined,\n    };\n  }\n\n  /**\n   * Index a node for search\n   */\n  private async indexNodeForSearch(node: any): Promise<void> {\n    const searchTerms = new Set<string>();\n\n    // Index label\n    const labelTerms = node.label.toLowerCase().split(/\\s+/);\n    labelTerms.forEach((term: string) => searchTerms.add(term));\n\n    // Index important properties\n    const properties = typeof node.properties === 'string' ? JSON.parse(node.properties) : node.properties;\n\n    for (const [, value] of Object.entries(properties)) {\n      if (typeof value === 'string') {\n        const terms = value.toLowerCase().split(/\\s+/);\n        terms.forEach((term: string) => searchTerms.add(term));\n      }\n    }\n\n    // Insert search indices\n    for (const term of searchTerms) {\n      await this.adapter.insertSearchIndex({\n        term,\n        nodeId: node.id,\n        field: 'label',\n        weight: 1.0,\n      });\n    }\n  }\n\n  /**\n   * Traverse graph helper\n   */\n  private async traverseGraph(\n    nodeId: string,\n    depth: number,\n    direction: 'in' | 'out' | 'both',\n    edgeTypes: (EdgeType | string)[] | undefined,\n    visitedNodes: Map<string, KnowledgeNode>,\n    visitedEdges: Map<string, KnowledgeEdge>,\n    currentDepth = 0\n  ): Promise<void> {\n    if (currentDepth >= depth) return;\n\n    // Get edges based on direction\n    const edges: any[] = [];\n\n    if (direction === 'out' || direction === 'both') {\n      const outEdges = await this.adapter.queryEdges({ fromNodeId: nodeId });\n      edges.push(...outEdges);\n    }\n\n    if (direction === 'in' || direction === 'both') {\n      const inEdges = await this.adapter.queryEdges({ toNodeId: nodeId });\n      edges.push(...inEdges);\n    }\n\n    for (const edge of edges) {\n      if (edgeTypes && !edgeTypes.includes(edge.type)) continue;\n\n      visitedEdges.set(edge.id, this.normalizeEdge(edge));\n\n      const nextNodeId = edge.fromNodeId === nodeId ? edge.toNodeId : edge.fromNodeId;\n\n      if (!visitedNodes.has(nextNodeId)) {\n        const nextNode = await this.adapter.getNode(nextNodeId);\n        if (nextNode) {\n          visitedNodes.set(nextNodeId, this.normalizeNode(nextNode));\n\n          await this.traverseGraph(nextNodeId, depth, direction, edgeTypes, visitedNodes, visitedEdges, currentDepth + 1);\n        }\n      }\n    }\n  }\n\n  /**\n   * Calculate relevance score\n   */\n  private calculateRelevance(nodeCount: number, edgeCount: number): number {\n    return Math.min(1, (nodeCount + edgeCount) / 10);\n  }\n}\n","/**\n * Core types for the knowledge graph system\n */\n\n/**\n * Type for node types - users define their own enums\n */\nexport type NodeType = string;\n\n/**\n * Common edge types that users can extend\n */\nexport enum CommonEdgeType {\n  // Generic relationships\n  RELATED_TO = 'RELATED_TO',\n  SIMILAR_TO = 'SIMILAR_TO',\n  OPPOSITE_OF = 'OPPOSITE_OF',\n  PART_OF = 'PART_OF',\n  HAS_PART = 'HAS_PART',\n\n  // Personal relationships\n  KNOWS = 'KNOWS',\n  FRIEND_OF = 'FRIEND_OF',\n  COLLEAGUE_OF = 'COLLEAGUE_OF',\n  REPORTS_TO = 'REPORTS_TO',\n  MANAGES = 'MANAGES',\n\n  // Family relationships\n  HAS_FAMILY_MEMBER = 'HAS_FAMILY_MEMBER',\n  PARENT_OF = 'PARENT_OF',\n  CHILD_OF = 'CHILD_OF',\n  SPOUSE_OF = 'SPOUSE_OF',\n  SIBLING_OF = 'SIBLING_OF',\n\n  // Location relationships\n  LIVES_AT = 'LIVES_AT',\n  WORKS_AT = 'WORKS_AT',\n  LOCATED_IN = 'LOCATED_IN',\n  VISITED = 'VISITED',\n  PLANS_TO_VISIT = 'PLANS_TO_VISIT',\n\n  // Ownership relationships\n  OWNS = 'OWNS',\n  OWNED_BY = 'OWNED_BY',\n  CREATED_BY = 'CREATED_BY',\n  CREATED = 'CREATED',\n\n  // Financial relationships\n  PAID_TO = 'PAID_TO',\n  RECEIVED_FROM = 'RECEIVED_FROM',\n  SAVED_FOR = 'SAVED_FOR',\n  SPENT_ON = 'SPENT_ON',\n  EARNS_FROM = 'EARNS_FROM',\n  INVESTS_IN = 'INVESTS_IN',\n\n  // Career relationships\n  EMPLOYED_BY = 'EMPLOYED_BY',\n  EMPLOYS = 'EMPLOYS',\n  HAS_SKILL = 'HAS_SKILL',\n  REQUIRES_SKILL = 'REQUIRES_SKILL',\n  STUDIED_AT = 'STUDIED_AT',\n  GRADUATED_FROM = 'GRADUATED_FROM',\n\n  // Temporal relationships\n  HAPPENED_BEFORE = 'HAPPENED_BEFORE',\n  HAPPENED_AFTER = 'HAPPENED_AFTER',\n  HAPPENED_DURING = 'HAPPENED_DURING',\n  CAUSED = 'CAUSED',\n  CAUSED_BY = 'CAUSED_BY',\n\n  // Preference relationships\n  LIKES = 'LIKES',\n  DISLIKES = 'DISLIKES',\n  INTERESTED_IN = 'INTERESTED_IN',\n  PREFERS = 'PREFERS',\n\n  // Action relationships\n  PARTICIPATED_IN = 'PARTICIPATED_IN',\n  ATTENDED = 'ATTENDED',\n  ORGANIZED = 'ORGANIZED',\n  MENTIONED = 'MENTIONED',\n  REFERENCED = 'REFERENCED',\n\n  // Document/Information relationships\n  CONTAINS = 'CONTAINS',\n  CONTAINED_IN = 'CONTAINED_IN',\n  DERIVED_FROM = 'DERIVED_FROM',\n  BASED_ON = 'BASED_ON',\n}\n\n/**\n * Type for edge types - users can extend CommonEdgeType or define their own\n */\nexport type EdgeType = CommonEdgeType | string;\n\n/**\n * Core knowledge node interface\n */\nexport interface KnowledgeNode<T = Record<string, unknown>> {\n  id: string;\n  type: NodeType | string;\n  label: string;\n  properties: T;\n  confidence: number;\n  createdAt: Date;\n  updatedAt: Date;\n  sourceSessionIds?: string[];\n}\n\n/**\n * Core knowledge edge interface\n */\nexport interface KnowledgeEdge<T = Record<string, unknown>> {\n  id: string;\n  type: EdgeType | string;\n  fromNodeId: string;\n  toNodeId: string;\n  properties: T;\n  confidence: number;\n  createdAt: Date;\n  sourceSessionIds?: string[];\n}\n\n/**\n * Query result containing nodes and edges\n */\nexport interface QueryResult<N = KnowledgeNode, E = KnowledgeEdge> {\n  nodes: N[];\n  edges: E[];\n  relevanceScore?: number;\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Options for graph queries\n */\nexport interface QueryOptions {\n  limit?: number;\n  offset?: number;\n  minConfidence?: number;\n  includeEdges?: boolean;\n  depth?: number;\n  direction?: 'in' | 'out' | 'both';\n  nodeTypes?: (NodeType | string)[];\n  edgeTypes?: (EdgeType | string)[];\n  orderBy?: 'confidence' | 'createdAt' | 'updatedAt' | 'relevance';\n  orderDirection?: 'asc' | 'desc';\n}\n\n/**\n * Options for node creation/update\n */\nexport interface NodeOptions<TNodeType extends string = string, TProperties = Record<string, unknown>> {\n  type: TNodeType;\n  label: string;\n  properties?: TProperties;\n  confidence?: number;\n  sourceSessionId?: string;\n  mergeStrategy?: 'replace' | 'merge' | 'skip';\n}\n\n/**\n * Options for edge creation/update\n */\nexport interface EdgeOptions<TEdgeType extends string = string, TProperties = Record<string, unknown>> {\n  type: TEdgeType;\n  fromNodeId: string;\n  toNodeId: string;\n  properties?: TProperties;\n  confidence?: number;\n  sourceSessionId?: string;\n  bidirectional?: boolean;\n}\n\n/**\n * Graph traversal options\n */\nexport interface TraversalOptions {\n  startNodeId: string;\n  direction?: 'in' | 'out' | 'both';\n  maxDepth?: number;\n  edgeTypes?: (EdgeType | string)[];\n  nodeFilter?: (node: KnowledgeNode) => boolean;\n  edgeFilter?: (edge: KnowledgeEdge) => boolean;\n  visitOnce?: boolean;\n}\n\n/**\n * Path finding result\n */\nexport interface Path<N = KnowledgeNode, E = KnowledgeEdge> {\n  nodes: N[];\n  edges: E[];\n  length: number;\n  weight?: number;\n}\n\n/**\n * Graph statistics\n */\nexport interface GraphStats {\n  nodeCount: number;\n  edgeCount: number;\n  nodesByType: Record<string, number>;\n  edgesByType: Record<string, number>;\n  averageDegree: number;\n  density: number;\n  lastUpdated: Date;\n}\n\n/**\n * Extracted knowledge data for processing\n */\nexport interface ExtractedNodeData<T = Record<string, unknown>> {\n  type: NodeType | string;\n  label: string;\n  properties: T;\n  confidence: number;\n  sourceSessionIds?: string[];\n}\n\nexport interface ExtractedEdgeData<T = Record<string, unknown>> {\n  type: EdgeType | string;\n  fromNodeLabel: string;\n  toNodeLabel: string;\n  properties: T;\n  confidence: number;\n  sourceSessionIds?: string[];\n}\n\nexport interface ExtractedKnowledge<N = ExtractedNodeData, E = ExtractedEdgeData> {\n  nodes: N[];\n  edges: E[];\n  confidence: number;\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Search options\n */\nexport interface SearchOptions {\n  query: string;\n  fields?: ('label' | 'properties' | string)[];\n  nodeTypes?: (NodeType | string)[];\n  fuzzy?: boolean;\n  limit?: number;\n  minScore?: number;\n}\n\n/**\n * Batch operation results\n */\nexport interface BatchResult {\n  successful: number;\n  failed: number;\n  errors?: Array<{ item: unknown; error: Error }>;\n}\n\n/**\n * Migration interface for version upgrades\n */\nexport interface Migration {\n  version: string;\n  up: (db: unknown) => Promise<void>;\n  down: (db: unknown) => Promise<void>;\n  description?: string;\n}\n","import type { Node, Edge, NodeIndex, EdgeIndex, SearchIndex, NewNode, NewEdge, NewNodeIndex, NewEdgeIndex, NewSearchIndex } from '../schema';\n\n/**\n * Base adapter interface for database operations\n * All adapters must implement this interface\n */\nexport interface DatabaseAdapter {\n  /**\n   * Initialize the database schema\n   */\n  initialize(): Promise<void>;\n\n  /**\n   * Execute a raw SQL query\n   */\n  execute<T = unknown>(query: string, params?: unknown[]): Promise<T[]>;\n\n  /**\n   * Begin a transaction\n   */\n  transaction<T>(fn: (tx: TransactionContext) => Promise<T>): Promise<T>;\n\n  /**\n   * Node operations\n   */\n  insertNode(node: NewNode): Promise<Node>;\n  updateNode(id: string, updates: Partial<NewNode>): Promise<Node | null>;\n  deleteNode(id: string): Promise<boolean>;\n  getNode(id: string): Promise<Node | null>;\n  getNodes(ids: string[]): Promise<Node[]>;\n  queryNodes(conditions: Record<string, unknown>, limit?: number, offset?: number): Promise<Node[]>;\n\n  /**\n   * Edge operations\n   */\n  insertEdge(edge: NewEdge): Promise<Edge>;\n  updateEdge(id: string, updates: Partial<NewEdge>): Promise<Edge | null>;\n  deleteEdge(id: string): Promise<boolean>;\n  getEdge(id: string): Promise<Edge | null>;\n  getEdges(ids: string[]): Promise<Edge[]>;\n  queryEdges(conditions: Record<string, unknown>, limit?: number, offset?: number): Promise<Edge[]>;\n\n  /**\n   * Index operations\n   */\n  insertNodeIndex(index: NewNodeIndex): Promise<NodeIndex>;\n  deleteNodeIndex(indexKey: string, nodeId?: string): Promise<number>;\n  getNodeIndices(indexKey: string): Promise<NodeIndex[]>;\n\n  insertEdgeIndex(index: NewEdgeIndex): Promise<EdgeIndex>;\n  deleteEdgeIndex(indexKey: string, edgeId?: string): Promise<number>;\n  getEdgeIndices(indexKey: string): Promise<EdgeIndex[]>;\n\n  /**\n   * Search operations\n   */\n  insertSearchIndex(index: NewSearchIndex): Promise<SearchIndex>;\n  deleteSearchIndex(nodeId: string): Promise<number>;\n  searchNodes(term: string, limit?: number): Promise<SearchIndex[]>;\n\n  /**\n   * Batch operations\n   */\n  batchInsertNodes(nodes: NewNode[]): Promise<Node[]>;\n  batchInsertEdges(edges: NewEdge[]): Promise<Edge[]>;\n  batchDeleteNodes(ids: string[]): Promise<number>;\n  batchDeleteEdges(ids: string[]): Promise<number>;\n\n  /**\n   * Cleanup and maintenance\n   */\n  vacuum(): Promise<void>;\n  getStats(): Promise<DatabaseStats>;\n  close(): Promise<void>;\n}\n\n/**\n * Transaction context for atomic operations\n */\nexport interface TransactionContext {\n  execute<T = unknown>(query: string, params?: unknown[]): Promise<T[]>;\n  rollback(): Promise<void>;\n}\n\n/**\n * Database statistics\n */\nexport interface DatabaseStats {\n  nodeCount: number;\n  edgeCount: number;\n  indexCount: number;\n  sizeInBytes?: number;\n  lastVacuum?: Date;\n}\n\n/**\n * Adapter configuration\n */\nexport interface AdapterConfig {\n  /**\n   * Database connection string or configuration\n   */\n  connection?: string | Record<string, unknown>;\n\n  /**\n   * Enable debug logging\n   */\n  debug?: boolean;\n\n  /**\n   * Custom table prefix\n   */\n  tablePrefix?: string;\n\n  /**\n   * Auto-create tables if they don't exist\n   */\n  autoCreate?: boolean;\n\n  /**\n   * Additional adapter-specific options\n   */\n  options?: Record<string, unknown>;\n}\n\n/**\n * Base adapter class with common functionality\n */\nexport abstract class BaseAdapter implements DatabaseAdapter {\n  protected config: AdapterConfig;\n  protected tablePrefix: string;\n\n  constructor(config: AdapterConfig = {}) {\n    this.config = config;\n    this.tablePrefix = config.tablePrefix || '';\n  }\n\n  protected getTableName(table: string): string {\n    return this.tablePrefix ? `${this.tablePrefix}_${table}` : table;\n  }\n\n\n  protected log(_message: string, ..._args: unknown[]): void {\n    // Logging disabled for now to avoid console warnings\n    // if (this.config.debug) {\n    //   console.log(`[KnowledgeGraph] ${message}`, ...args);\n    // }\n  }\n\n  protected error(message: string, error?: unknown): void {\n    // Use console.error which is allowed by linter\n    console.error(`[KnowledgeGraph Error] ${message}`, error);\n  }\n\n  // Abstract methods that must be implemented by subclasses\n  abstract initialize(): Promise<void>;\n  abstract execute<T = unknown>(query: string, params?: any[]): Promise<T[]>;\n  abstract transaction<T>(fn: (tx: TransactionContext) => Promise<T>): Promise<T>;\n\n  abstract insertNode(node: NewNode): Promise<Node>;\n  abstract updateNode(id: string, updates: Partial<NewNode>): Promise<Node | null>;\n  abstract deleteNode(id: string): Promise<boolean>;\n  abstract getNode(id: string): Promise<Node | null>;\n  abstract getNodes(ids: string[]): Promise<Node[]>;\n  abstract queryNodes(conditions: Record<string, any>, limit?: number, offset?: number): Promise<Node[]>;\n\n  abstract insertEdge(edge: NewEdge): Promise<Edge>;\n  abstract updateEdge(id: string, updates: Partial<NewEdge>): Promise<Edge | null>;\n  abstract deleteEdge(id: string): Promise<boolean>;\n  abstract getEdge(id: string): Promise<Edge | null>;\n  abstract getEdges(ids: string[]): Promise<Edge[]>;\n  abstract queryEdges(conditions: Record<string, any>, limit?: number, offset?: number): Promise<Edge[]>;\n\n  abstract insertNodeIndex(index: NewNodeIndex): Promise<NodeIndex>;\n  abstract deleteNodeIndex(indexKey: string, nodeId?: string): Promise<number>;\n  abstract getNodeIndices(indexKey: string): Promise<NodeIndex[]>;\n\n  abstract insertEdgeIndex(index: NewEdgeIndex): Promise<EdgeIndex>;\n  abstract deleteEdgeIndex(indexKey: string, edgeId?: string): Promise<number>;\n  abstract getEdgeIndices(indexKey: string): Promise<EdgeIndex[]>;\n\n  abstract insertSearchIndex(index: NewSearchIndex): Promise<SearchIndex>;\n  abstract deleteSearchIndex(nodeId: string): Promise<number>;\n  abstract searchNodes(term: string, limit?: number): Promise<SearchIndex[]>;\n\n  abstract batchInsertNodes(nodes: NewNode[]): Promise<Node[]>;\n  abstract batchInsertEdges(edges: NewEdge[]): Promise<Edge[]>;\n  abstract batchDeleteNodes(ids: string[]): Promise<number>;\n  abstract batchDeleteEdges(ids: string[]): Promise<number>;\n\n  abstract vacuum(): Promise<void>;\n  abstract getStats(): Promise<DatabaseStats>;\n  abstract close(): Promise<void>;\n}\n","import Database from 'better-sqlite3';\nimport { drizzle } from 'drizzle-orm/better-sqlite3';\nimport { eq, and, inArray, like } from 'drizzle-orm';\nimport { BaseAdapter, TransactionContext, DatabaseStats, AdapterConfig } from './base';\nimport * as schema from '../schema';\nimport type { Node, Edge, NodeIndex, EdgeIndex, SearchIndex, NewNode, NewEdge, NewNodeIndex, NewEdgeIndex, NewSearchIndex } from '../schema';\n\n/**\n * SQLite adapter implementation using better-sqlite3\n */\nexport class SQLiteAdapter extends BaseAdapter {\n  private db: Database.Database | null = null;\n  private drizzle: ReturnType<typeof drizzle> | null = null;\n\n  constructor(config: AdapterConfig = {}) {\n    super(config);\n  }\n\n  async initialize(): Promise<void> {\n    try {\n      const dbPath = (this.config.connection as string) || ':memory:';\n      this.db = new Database(dbPath);\n      this.drizzle = drizzle(this.db);\n\n      // Enable foreign keys\n      this.db.exec('PRAGMA foreign_keys = ON');\n\n      if (this.config.autoCreate !== false) {\n        await this.createTables();\n      }\n\n      this.log('SQLite adapter initialized', { path: dbPath });\n    } catch (error) {\n      this.error('Failed to initialize SQLite adapter', error);\n      throw error;\n    }\n  }\n\n  private async createTables(): Promise<void> {\n    if (!this.db) throw new Error('Database not initialized');\n\n    // Create nodes table\n    this.db.exec(`\n      CREATE TABLE IF NOT EXISTS kg_nodes (\n        id TEXT PRIMARY KEY,\n        type TEXT NOT NULL,\n        label TEXT NOT NULL,\n        properties TEXT NOT NULL DEFAULT '{}',\n        confidence REAL NOT NULL DEFAULT 1.0,\n        created_at INTEGER NOT NULL,\n        updated_at INTEGER NOT NULL,\n        source_session_ids TEXT\n      );\n      CREATE INDEX IF NOT EXISTS idx_nodes_type ON kg_nodes(type);\n      CREATE INDEX IF NOT EXISTS idx_nodes_label ON kg_nodes(label);\n      CREATE INDEX IF NOT EXISTS idx_nodes_created_at ON kg_nodes(created_at);\n    `);\n\n    // Create edges table\n    this.db.exec(`\n      CREATE TABLE IF NOT EXISTS kg_edges (\n        id TEXT PRIMARY KEY,\n        type TEXT NOT NULL,\n        from_node_id TEXT NOT NULL REFERENCES kg_nodes(id) ON DELETE CASCADE,\n        to_node_id TEXT NOT NULL REFERENCES kg_nodes(id) ON DELETE CASCADE,\n        properties TEXT NOT NULL DEFAULT '{}',\n        confidence REAL NOT NULL DEFAULT 1.0,\n        created_at INTEGER NOT NULL,\n        source_session_ids TEXT\n      );\n      CREATE INDEX IF NOT EXISTS idx_edges_type ON kg_edges(type);\n      CREATE INDEX IF NOT EXISTS idx_edges_from_node ON kg_edges(from_node_id);\n      CREATE INDEX IF NOT EXISTS idx_edges_to_node ON kg_edges(to_node_id);\n      CREATE INDEX IF NOT EXISTS idx_edges_from_type ON kg_edges(from_node_id, type);\n      CREATE INDEX IF NOT EXISTS idx_edges_to_type ON kg_edges(to_node_id, type);\n    `);\n\n    // Create node indices table\n    this.db.exec(`\n      CREATE TABLE IF NOT EXISTS kg_node_indices (\n        index_key TEXT NOT NULL,\n        node_id TEXT NOT NULL REFERENCES kg_nodes(id) ON DELETE CASCADE,\n        created_at INTEGER NOT NULL,\n        PRIMARY KEY (index_key, node_id)\n      );\n      CREATE INDEX IF NOT EXISTS idx_node_indices_key ON kg_node_indices(index_key);\n      CREATE INDEX IF NOT EXISTS idx_node_indices_node ON kg_node_indices(node_id);\n    `);\n\n    // Create edge indices table\n    this.db.exec(`\n      CREATE TABLE IF NOT EXISTS kg_edge_indices (\n        index_key TEXT NOT NULL,\n        edge_id TEXT NOT NULL REFERENCES kg_edges(id) ON DELETE CASCADE,\n        created_at INTEGER NOT NULL,\n        PRIMARY KEY (index_key, edge_id)\n      );\n      CREATE INDEX IF NOT EXISTS idx_edge_indices_key ON kg_edge_indices(index_key);\n      CREATE INDEX IF NOT EXISTS idx_edge_indices_edge ON kg_edge_indices(edge_id);\n    `);\n\n    // Create search index table\n    this.db.exec(`\n      CREATE TABLE IF NOT EXISTS kg_search_index (\n        term TEXT NOT NULL,\n        node_id TEXT NOT NULL REFERENCES kg_nodes(id) ON DELETE CASCADE,\n        field TEXT NOT NULL,\n        weight REAL NOT NULL DEFAULT 1.0,\n        PRIMARY KEY (term, node_id, field)\n      );\n      CREATE INDEX IF NOT EXISTS idx_search_term ON kg_search_index(term);\n      CREATE INDEX IF NOT EXISTS idx_search_node ON kg_search_index(node_id);\n    `);\n\n    // Create graph metadata table\n    this.db.exec(`\n      CREATE TABLE IF NOT EXISTS kg_graph_metadata (\n        key TEXT PRIMARY KEY,\n        value TEXT NOT NULL,\n        updated_at INTEGER NOT NULL\n      );\n    `);\n  }\n\n  async execute<T = unknown>(query: string, params: unknown[] = []): Promise<T[]> {\n    if (!this.db) throw new Error('Database not initialized');\n\n    try {\n      const stmt = this.db.prepare(query);\n      return stmt.all(...params) as T[];\n    } catch (error) {\n      this.error('Query execution failed', { query, params, error });\n      throw error;\n    }\n  }\n\n  async executeUpdate(query: string, params: unknown[] = []): Promise<{ changes: number }> {\n    if (!this.db) throw new Error('Database not initialized');\n\n    try {\n      const stmt = this.db.prepare(query);\n      return stmt.run(...params);\n    } catch (error) {\n      this.error('Query execution failed', { query, params, error });\n      throw error;\n    }\n  }\n\n  async transaction<T>(fn: (tx: TransactionContext) => Promise<T>): Promise<T> {\n    if (!this.db) throw new Error('Database not initialized');\n\n    return new Promise((resolve, reject) => {\n      try {\n        if (!this.db) throw new Error('Database not initialized');\n        const result = this.db.transaction(async () => {\n          const tx: TransactionContext = {\n            execute: async <U = unknown>(query: string, params: unknown[] = []): Promise<U[]> => {\n              return this.execute<U>(query, params);\n            },\n            rollback: async () => {\n              throw new Error('Transaction rollback');\n            },\n          };\n\n          return await fn(tx);\n        })();\n\n        resolve(result);\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  // Node operations\n  async insertNode(node: NewNode): Promise<Node> {\n    if (!this.drizzle) throw new Error('Database not initialized');\n\n    const result = await this.drizzle.insert(schema.nodes).values(node).returning();\n    const insertedNode = result[0];\n    if (!insertedNode) throw new Error('Failed to create node');\n    return this.deserializeNode(insertedNode);\n  }\n\n  async updateNode(id: string, updates: Partial<NewNode>): Promise<Node | null> {\n    if (!this.drizzle) throw new Error('Database not initialized');\n\n    const result = await this.drizzle\n      .update(schema.nodes)\n      .set({ ...updates, updatedAt: new Date() })\n      .where(eq(schema.nodes.id, id))\n      .returning();\n\n    return result[0] ? this.deserializeNode(result[0]) : null;\n  }\n\n  async deleteNode(id: string): Promise<boolean> {\n    const query = `DELETE FROM kg_nodes WHERE id = ?`;\n    const result = await this.executeUpdate(query, [id]);\n    return result.changes > 0;\n  }\n\n  async getNode(id: string): Promise<Node | null> {\n    if (!this.drizzle) throw new Error('Database not initialized');\n\n    const result = await this.drizzle.select().from(schema.nodes).where(eq(schema.nodes.id, id)).limit(1);\n\n    return result[0] ? this.deserializeNode(result[0]) : null;\n  }\n\n  async getNodes(ids: string[]): Promise<Node[]> {\n    if (!this.drizzle || ids.length === 0) return [];\n\n    const result = await this.drizzle.select().from(schema.nodes).where(inArray(schema.nodes.id, ids));\n\n    return result.map((n) => this.deserializeNode(n));\n  }\n\n  async queryNodes(conditions: Record<string, unknown>, limit = 100, offset = 0): Promise<Node[]> {\n    if (!this.drizzle) throw new Error('Database not initialized');\n\n    const whereConditions = Object.entries(conditions).map(([key, value]) => {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const column = (schema.nodes as any)[key];\n      return eq(column, value);\n    });\n\n    const result = await this.drizzle\n      .select()\n      .from(schema.nodes)\n      .where(and(...whereConditions))\n      .limit(limit)\n      .offset(offset);\n\n    return result.map((n) => this.deserializeNode(n));\n  }\n\n  // Edge operations\n  async insertEdge(edge: NewEdge): Promise<Edge> {\n    if (!this.drizzle) throw new Error('Database not initialized');\n\n    const result = await this.drizzle.insert(schema.edges).values(edge).returning();\n    const insertedEdge = result[0];\n    if (!insertedEdge) throw new Error('Failed to create edge');\n    return this.deserializeEdge(insertedEdge);\n  }\n\n  async updateEdge(id: string, updates: Partial<NewEdge>): Promise<Edge | null> {\n    if (!this.drizzle) throw new Error('Database not initialized');\n\n    const result = await this.drizzle.update(schema.edges).set(updates).where(eq(schema.edges.id, id)).returning();\n\n    return result[0] ? this.deserializeEdge(result[0]) : null;\n  }\n\n  async deleteEdge(id: string): Promise<boolean> {\n    const query = `DELETE FROM kg_edges WHERE id = ?`;\n    await this.execute(query, [id]);\n    return true;\n  }\n\n  async getEdge(id: string): Promise<Edge | null> {\n    if (!this.drizzle) throw new Error('Database not initialized');\n\n    const result = await this.drizzle.select().from(schema.edges).where(eq(schema.edges.id, id)).limit(1);\n\n    return result[0] ? this.deserializeEdge(result[0]) : null;\n  }\n\n  async getEdges(ids: string[]): Promise<Edge[]> {\n    if (!this.drizzle || ids.length === 0) return [];\n\n    const result = await this.drizzle.select().from(schema.edges).where(inArray(schema.edges.id, ids));\n\n    return result.map((e) => this.deserializeEdge(e));\n  }\n\n  async queryEdges(conditions: Record<string, unknown>, limit = 100, offset = 0): Promise<Edge[]> {\n    if (!this.drizzle) throw new Error('Database not initialized');\n\n    const whereConditions = Object.entries(conditions).map(([key, value]) => {\n      // Map camelCase to snake_case for schema fields (Drizzle schema uses camelCase in TypeScript)\n      const fieldMap: Record<string, string> = {\n        'from_node_id': 'fromNodeId',\n        'to_node_id': 'toNodeId',\n        'created_at': 'createdAt',\n        'updated_at': 'updatedAt',\n        'source_session_ids': 'sourceSessionIds'\n      };\n      const schemaKey = fieldMap[key] || key;\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const column = (schema.edges as any)[schemaKey];\n      return eq(column, value);\n    });\n\n    const result = await this.drizzle\n      .select()\n      .from(schema.edges)\n      .where(and(...whereConditions))\n      .limit(limit)\n      .offset(offset);\n\n    return result.map((e) => this.deserializeEdge(e));\n  }\n\n  // Index operations\n  async insertNodeIndex(index: NewNodeIndex): Promise<NodeIndex> {\n    if (!this.drizzle) throw new Error('Database not initialized');\n\n    const result = await this.drizzle.insert(schema.nodeIndices).values(index).returning();\n    const insertedIndex = result[0];\n    if (!insertedIndex) throw new Error('Failed to create node index');\n    return insertedIndex;\n  }\n\n  async deleteNodeIndex(indexKey: string, nodeId?: string): Promise<number> {\n    const query = nodeId ? `DELETE FROM kg_node_indices WHERE index_key = ? AND node_id = ?` : `DELETE FROM kg_node_indices WHERE index_key = ?`;\n    const params = nodeId ? [indexKey, nodeId] : [indexKey];\n\n    if (!this.db) throw new Error('Database not initialized');\n    const stmt = this.db.prepare(query);\n    const info = stmt.run(params);\n    return info.changes;\n  }\n\n  async getNodeIndices(indexKey: string): Promise<NodeIndex[]> {\n    if (!this.drizzle) throw new Error('Database not initialized');\n\n    return await this.drizzle.select().from(schema.nodeIndices).where(eq(schema.nodeIndices.indexKey, indexKey));\n  }\n\n  async insertEdgeIndex(index: NewEdgeIndex): Promise<EdgeIndex> {\n    if (!this.drizzle) throw new Error('Database not initialized');\n\n    const result = await this.drizzle.insert(schema.edgeIndices).values(index).returning();\n    const insertedIndex = result[0];\n    if (!insertedIndex) throw new Error('Failed to create edge index');\n    return insertedIndex;\n  }\n\n  async deleteEdgeIndex(indexKey: string, edgeId?: string): Promise<number> {\n    const query = edgeId ? `DELETE FROM kg_edge_indices WHERE index_key = ? AND edge_id = ?` : `DELETE FROM kg_edge_indices WHERE index_key = ?`;\n    const params = edgeId ? [indexKey, edgeId] : [indexKey];\n\n    if (!this.db) throw new Error('Database not initialized');\n    const stmt = this.db.prepare(query);\n    const info = stmt.run(params);\n    return info.changes;\n  }\n\n  async getEdgeIndices(indexKey: string): Promise<EdgeIndex[]> {\n    if (!this.drizzle) throw new Error('Database not initialized');\n\n    return await this.drizzle.select().from(schema.edgeIndices).where(eq(schema.edgeIndices.indexKey, indexKey));\n  }\n\n  // Search operations\n  async insertSearchIndex(index: NewSearchIndex): Promise<SearchIndex> {\n    if (!this.drizzle) throw new Error('Database not initialized');\n\n    const result = await this.drizzle.insert(schema.searchIndex).values(index).returning();\n    const insertedIndex = result[0];\n    if (!insertedIndex) throw new Error('Failed to create search index');\n    return insertedIndex;\n  }\n\n  async deleteSearchIndex(nodeId: string): Promise<number> {\n    const query = `DELETE FROM kg_search_index WHERE node_id = ?`;\n    if (!this.db) throw new Error('Database not initialized');\n    const stmt = this.db.prepare(query);\n    const info = stmt.run([nodeId]);\n    return info.changes;\n  }\n\n  async searchNodes(term: string, limit = 50): Promise<SearchIndex[]> {\n    if (!this.drizzle) throw new Error('Database not initialized');\n\n    return await this.drizzle\n      .select()\n      .from(schema.searchIndex)\n      .where(like(schema.searchIndex.term, `%${term}%`))\n      .limit(limit);\n  }\n\n  // Batch operations\n  async batchInsertNodes(nodes: NewNode[]): Promise<Node[]> {\n    if (!this.drizzle || nodes.length === 0) return [];\n\n    const result = await this.drizzle.insert(schema.nodes).values(nodes).returning();\n    return result.map((n) => this.deserializeNode(n));\n  }\n\n  async batchInsertEdges(edges: NewEdge[]): Promise<Edge[]> {\n    if (!this.drizzle || edges.length === 0) return [];\n\n    const result = await this.drizzle.insert(schema.edges).values(edges).returning();\n    return result.map((e) => this.deserializeEdge(e));\n  }\n\n  async batchDeleteNodes(ids: string[]): Promise<number> {\n    if (ids.length === 0) return 0;\n\n    const placeholders = ids.map(() => '?').join(',');\n    const query = `DELETE FROM kg_nodes WHERE id IN (${placeholders})`;\n    if (!this.db) throw new Error('Database not initialized');\n    const stmt = this.db.prepare(query);\n    const info = stmt.run(ids);\n    return info.changes;\n  }\n\n  async batchDeleteEdges(ids: string[]): Promise<number> {\n    if (ids.length === 0) return 0;\n\n    const placeholders = ids.map(() => '?').join(',');\n    const query = `DELETE FROM kg_edges WHERE id IN (${placeholders})`;\n    if (!this.db) throw new Error('Database not initialized');\n    const stmt = this.db.prepare(query);\n    const info = stmt.run(ids);\n    return info.changes;\n  }\n\n  // Maintenance operations\n  async vacuum(): Promise<void> {\n    if (!this.db) throw new Error('Database not initialized');\n\n    this.db.exec('VACUUM');\n    this.log('Database vacuumed');\n  }\n\n  async getStats(): Promise<DatabaseStats> {\n    if (!this.db) throw new Error('Database not initialized');\n\n    const nodeCount = this.db.prepare('SELECT COUNT(*) as count FROM kg_nodes').get() as {count: number};\n    const edgeCount = this.db.prepare('SELECT COUNT(*) as count FROM kg_edges').get() as {count: number};\n    const indexCount = this.db.prepare('SELECT COUNT(*) as count FROM kg_node_indices').get() as {count: number};\n\n    return {\n      nodeCount: nodeCount.count,\n      edgeCount: edgeCount.count,\n      indexCount: indexCount.count,\n    };\n  }\n\n  async close(): Promise<void> {\n    if (this.db) {\n      this.db.close();\n      this.db = null;\n      this.drizzle = null;\n      this.log('Database connection closed');\n    }\n  }\n\n  // Helper methods\n  private deserializeNode(node: schema.Node): Node {\n    return {\n      ...node,\n      properties: JSON.parse(node.properties),\n      sourceSessionIds: node.sourceSessionIds ? JSON.parse(node.sourceSessionIds) : undefined,\n    };\n  }\n\n  private deserializeEdge(edge: schema.Edge): Edge {\n    return {\n      ...edge,\n      properties: JSON.parse(edge.properties),\n      sourceSessionIds: edge.sourceSessionIds ? JSON.parse(edge.sourceSessionIds) : undefined,\n    };\n  }\n}\n","import { sqliteTable, text, integer, index, primaryKey, real } from 'drizzle-orm/sqlite-core';\nimport { InferSelectModel, InferInsertModel } from 'drizzle-orm';\n\n/**\n * Nodes table - stores all graph nodes\n */\nexport const nodes = sqliteTable('kg_nodes', {\n  id: text('id').primaryKey(),\n  type: text('type').notNull(),\n  label: text('label').notNull(),\n  properties: text('properties').notNull(), // JSON string\n  confidence: real('confidence').notNull().default(1.0),\n  createdAt: integer('created_at', { mode: 'timestamp' }).notNull().$defaultFn(() => new Date()),\n  updatedAt: integer('updated_at', { mode: 'timestamp' }).notNull().$defaultFn(() => new Date()),\n  sourceSessionIds: text('source_session_ids'), // JSON array of session IDs\n}, (table) => ({\n  typeIdx: index('idx_nodes_type').on(table.type),\n  labelIdx: index('idx_nodes_label').on(table.label),\n  createdAtIdx: index('idx_nodes_created_at').on(table.createdAt),\n}));\n\n/**\n * Edges table - stores relationships between nodes\n */\nexport const edges = sqliteTable('kg_edges', {\n  id: text('id').primaryKey(),\n  type: text('type').notNull(),\n  fromNodeId: text('from_node_id').notNull().references(() => nodes.id, { onDelete: 'cascade' }),\n  toNodeId: text('to_node_id').notNull().references(() => nodes.id, { onDelete: 'cascade' }),\n  properties: text('properties').notNull().default('{}'), // JSON string\n  confidence: real('confidence').notNull().default(1.0),\n  createdAt: integer('created_at', { mode: 'timestamp' }).notNull().$defaultFn(() => new Date()),\n  sourceSessionIds: text('source_session_ids'), // JSON array of session IDs\n}, (table) => ({\n  typeIdx: index('idx_edges_type').on(table.type),\n  fromNodeIdx: index('idx_edges_from_node').on(table.fromNodeId),\n  toNodeIdx: index('idx_edges_to_node').on(table.toNodeId),\n  fromTypeIdx: index('idx_edges_from_type').on(table.fromNodeId, table.type),\n  toTypeIdx: index('idx_edges_to_type').on(table.toNodeId, table.type),\n}));\n\n/**\n * Node indices table - for efficient node lookups\n */\nexport const nodeIndices = sqliteTable('kg_node_indices', {\n  indexKey: text('index_key').notNull(),\n  nodeId: text('node_id').notNull().references(() => nodes.id, { onDelete: 'cascade' }),\n  createdAt: integer('created_at', { mode: 'timestamp' }).notNull().$defaultFn(() => new Date()),\n}, (table) => ({\n  pk: primaryKey({ columns: [table.indexKey, table.nodeId] }),\n  keyIdx: index('idx_node_indices_key').on(table.indexKey),\n  nodeIdx: index('idx_node_indices_node').on(table.nodeId),\n}));\n\n/**\n * Edge indices table - for efficient edge lookups\n */\nexport const edgeIndices = sqliteTable('kg_edge_indices', {\n  indexKey: text('index_key').notNull(),\n  edgeId: text('edge_id').notNull().references(() => edges.id, { onDelete: 'cascade' }),\n  createdAt: integer('created_at', { mode: 'timestamp' }).notNull().$defaultFn(() => new Date()),\n}, (table) => ({\n  pk: primaryKey({ columns: [table.indexKey, table.edgeId] }),\n  keyIdx: index('idx_edge_indices_key').on(table.indexKey),\n  edgeIdx: index('idx_edge_indices_edge').on(table.edgeId),\n}));\n\n/**\n * Search index table - for full-text search capabilities\n */\nexport const searchIndex = sqliteTable('kg_search_index', {\n  term: text('term').notNull(),\n  nodeId: text('node_id').notNull().references(() => nodes.id, { onDelete: 'cascade' }),\n  field: text('field').notNull(), // 'label', 'property:key', etc.\n  weight: real('weight').notNull().default(1.0),\n}, (table) => ({\n  pk: primaryKey({ columns: [table.term, table.nodeId, table.field] }),\n  termIdx: index('idx_search_term').on(table.term),\n  nodeIdx: index('idx_search_node').on(table.nodeId),\n}));\n\n/**\n * Graph metadata table - stores graph-level information\n */\nexport const graphMetadata = sqliteTable('kg_graph_metadata', {\n  key: text('key').primaryKey(),\n  value: text('value').notNull(),\n  updatedAt: integer('updated_at', { mode: 'timestamp' }).notNull().$defaultFn(() => new Date()),\n});\n\n// Type exports\nexport type Node = InferSelectModel<typeof nodes>;\nexport type NewNode = InferInsertModel<typeof nodes>;\nexport type Edge = InferSelectModel<typeof edges>;\nexport type NewEdge = InferInsertModel<typeof edges>;\nexport type NodeIndex = InferSelectModel<typeof nodeIndices>;\nexport type NewNodeIndex = InferInsertModel<typeof nodeIndices>;\nexport type EdgeIndex = InferSelectModel<typeof edgeIndices>;\nexport type NewEdgeIndex = InferInsertModel<typeof edgeIndices>;\nexport type SearchIndex = InferSelectModel<typeof searchIndex>;\nexport type NewSearchIndex = InferInsertModel<typeof searchIndex>;\nexport type GraphMetadata = InferSelectModel<typeof graphMetadata>;\nexport type NewGraphMetadata = InferInsertModel<typeof graphMetadata>;","import type { D1Database } from '@cloudflare/workers-types';\nimport { BaseAdapter, TransactionContext, DatabaseStats, AdapterConfig } from './base';\nimport type { \n  Node, Edge, NodeIndex, EdgeIndex, SearchIndex,\n  NewNode, NewEdge, NewNodeIndex, NewEdgeIndex, NewSearchIndex\n} from '../schema';\n\n/**\n * Cloudflare D1 adapter implementation\n * Uses raw SQL queries for compatibility with D1 in Durable Objects\n */\nexport class D1Adapter extends BaseAdapter {\n  private db: D1Database | null = null;\n  \n  constructor(config: AdapterConfig & { database?: D1Database }) {\n    super(config);\n    if (config.database) {\n      this.db = config.database;\n    }\n  }\n  \n  setDatabase(db: D1Database): void {\n    this.db = db;\n  }\n  \n  async initialize(): Promise<void> {\n    if (!this.db) {\n      throw new Error('D1 database not provided. Use setDatabase() or pass it in config.');\n    }\n    \n    if (this.config.autoCreate !== false) {\n      await this.createTables();\n    }\n    \n    this.log('D1 adapter initialized');\n  }\n  \n  private async createTables(): Promise<void> {\n    if (!this.db) throw new Error('Database not initialized');\n    \n    // Create nodes table\n    await this.db.exec(`\n      CREATE TABLE IF NOT EXISTS kg_nodes (\n        id TEXT PRIMARY KEY,\n        type TEXT NOT NULL,\n        label TEXT NOT NULL,\n        properties TEXT NOT NULL DEFAULT '{}',\n        confidence REAL NOT NULL DEFAULT 1.0,\n        created_at INTEGER NOT NULL,\n        updated_at INTEGER NOT NULL,\n        source_session_ids TEXT\n      );\n    `);\n    \n    await this.db.exec(`CREATE INDEX IF NOT EXISTS idx_nodes_type ON kg_nodes(type);`);\n    await this.db.exec(`CREATE INDEX IF NOT EXISTS idx_nodes_label ON kg_nodes(label);`);\n    await this.db.exec(`CREATE INDEX IF NOT EXISTS idx_nodes_created_at ON kg_nodes(created_at);`);\n    \n    // Create edges table\n    await this.db.exec(`\n      CREATE TABLE IF NOT EXISTS kg_edges (\n        id TEXT PRIMARY KEY,\n        type TEXT NOT NULL,\n        from_node_id TEXT NOT NULL,\n        to_node_id TEXT NOT NULL,\n        properties TEXT NOT NULL DEFAULT '{}',\n        confidence REAL NOT NULL DEFAULT 1.0,\n        created_at INTEGER NOT NULL,\n        source_session_ids TEXT,\n        FOREIGN KEY (from_node_id) REFERENCES kg_nodes(id) ON DELETE CASCADE,\n        FOREIGN KEY (to_node_id) REFERENCES kg_nodes(id) ON DELETE CASCADE\n      );\n    `);\n    \n    await this.db.exec(`CREATE INDEX IF NOT EXISTS idx_edges_type ON kg_edges(type);`);\n    await this.db.exec(`CREATE INDEX IF NOT EXISTS idx_edges_from_node ON kg_edges(from_node_id);`);\n    await this.db.exec(`CREATE INDEX IF NOT EXISTS idx_edges_to_node ON kg_edges(to_node_id);`);\n    await this.db.exec(`CREATE INDEX IF NOT EXISTS idx_edges_from_type ON kg_edges(from_node_id, type);`);\n    await this.db.exec(`CREATE INDEX IF NOT EXISTS idx_edges_to_type ON kg_edges(to_node_id, type);`);\n    \n    // Create indices tables\n    await this.db.exec(`\n      CREATE TABLE IF NOT EXISTS kg_node_indices (\n        index_key TEXT NOT NULL,\n        node_id TEXT NOT NULL,\n        created_at INTEGER NOT NULL,\n        PRIMARY KEY (index_key, node_id),\n        FOREIGN KEY (node_id) REFERENCES kg_nodes(id) ON DELETE CASCADE\n      );\n    `);\n    \n    await this.db.exec(`CREATE INDEX IF NOT EXISTS idx_node_indices_key ON kg_node_indices(index_key);`);\n    await this.db.exec(`CREATE INDEX IF NOT EXISTS idx_node_indices_node ON kg_node_indices(node_id);`);\n    \n    await this.db.exec(`\n      CREATE TABLE IF NOT EXISTS kg_edge_indices (\n        index_key TEXT NOT NULL,\n        edge_id TEXT NOT NULL,\n        created_at INTEGER NOT NULL,\n        PRIMARY KEY (index_key, edge_id),\n        FOREIGN KEY (edge_id) REFERENCES kg_edges(id) ON DELETE CASCADE\n      );\n    `);\n    \n    await this.db.exec(`CREATE INDEX IF NOT EXISTS idx_edge_indices_key ON kg_edge_indices(index_key);`);\n    await this.db.exec(`CREATE INDEX IF NOT EXISTS idx_edge_indices_edge ON kg_edge_indices(edge_id);`);\n    \n    // Create search index table\n    await this.db.exec(`\n      CREATE TABLE IF NOT EXISTS kg_search_index (\n        term TEXT NOT NULL,\n        node_id TEXT NOT NULL,\n        field TEXT NOT NULL,\n        weight REAL NOT NULL DEFAULT 1.0,\n        PRIMARY KEY (term, node_id, field),\n        FOREIGN KEY (node_id) REFERENCES kg_nodes(id) ON DELETE CASCADE\n      );\n    `);\n    \n    await this.db.exec(`CREATE INDEX IF NOT EXISTS idx_search_term ON kg_search_index(term);`);\n    await this.db.exec(`CREATE INDEX IF NOT EXISTS idx_search_node ON kg_search_index(node_id);`);\n    \n    // Create metadata table\n    await this.db.exec(`\n      CREATE TABLE IF NOT EXISTS kg_graph_metadata (\n        key TEXT PRIMARY KEY,\n        value TEXT NOT NULL,\n        updated_at INTEGER NOT NULL\n      );\n    `);\n  }\n  \n  async execute<T = unknown>(query: string, params: unknown[] = []): Promise<T[]> {\n    if (!this.db) throw new Error('Database not initialized');\n    \n    try {\n      const stmt = this.db.prepare(query).bind(...params);\n      const result = await stmt.all();\n      return result.results as T[];\n    } catch (error) {\n      this.error('Query execution failed', { query, params, error });\n      throw error;\n    }\n  }\n  \n  async transaction<T>(fn: (tx: TransactionContext) => Promise<T>): Promise<T> {\n    if (!this.db) throw new Error('Database not initialized');\n    \n    // D1 doesn't support explicit transactions in the same way\n    // We'll simulate it with a try-catch and manual rollback if needed\n    const tx: TransactionContext = {\n      execute: async <U = unknown>(query: string, params: unknown[] = []): Promise<U[]> => {\n        return this.execute<U>(query, params);\n      },\n      rollback: async () => {\n        throw new Error('Transaction rollback');\n      }\n    };\n    \n    try {\n      return await fn(tx);\n    } catch (error) {\n      this.error('Transaction failed', error);\n      throw error;\n    }\n  }\n  \n  // Node operations\n  async insertNode(node: NewNode): Promise<Node> {\n    const id = node.id || crypto.randomUUID();\n    const now = Date.now();\n    \n    const query = `\n      INSERT INTO kg_nodes (id, type, label, properties, confidence, created_at, updated_at, source_session_ids)\n      VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n    `;\n    \n    await this.execute(query, [\n      id,\n      node.type,\n      node.label,\n      JSON.stringify(node.properties || {}),\n      node.confidence || 1.0,\n      node.createdAt?.getTime() || now,\n      node.updatedAt?.getTime() || now,\n      node.sourceSessionIds ? JSON.stringify(node.sourceSessionIds) : null\n    ]);\n    \n    return this.getNode(id) as Promise<Node>;\n  }\n  \n  async updateNode(id: string, updates: Partial<NewNode>): Promise<Node | null> {\n    const setClauses: string[] = [];\n    const params: unknown[] = [];\n    \n    if (updates.type !== undefined) {\n      setClauses.push('type = ?');\n      params.push(updates.type);\n    }\n    if (updates.label !== undefined) {\n      setClauses.push('label = ?');\n      params.push(updates.label);\n    }\n    if (updates.properties !== undefined) {\n      setClauses.push('properties = ?');\n      params.push(JSON.stringify(updates.properties));\n    }\n    if (updates.confidence !== undefined) {\n      setClauses.push('confidence = ?');\n      params.push(updates.confidence);\n    }\n    if (updates.sourceSessionIds !== undefined) {\n      setClauses.push('source_session_ids = ?');\n      params.push(JSON.stringify(updates.sourceSessionIds));\n    }\n    \n    setClauses.push('updated_at = ?');\n    params.push(Date.now());\n    \n    params.push(id);\n    \n    const query = `UPDATE kg_nodes SET ${setClauses.join(', ')} WHERE id = ?`;\n    await this.execute(query, params);\n    \n    return this.getNode(id);\n  }\n  \n  async deleteNode(id: string): Promise<boolean> {\n    const query = `DELETE FROM kg_nodes WHERE id = ?`;\n    await this.execute(query, [id]);\n    return true;\n  }\n  \n  async getNode(id: string): Promise<Node | null> {\n    const query = `SELECT * FROM kg_nodes WHERE id = ? LIMIT 1`;\n    const results = await this.execute<Record<string, unknown>>(query, [id]);\n    \n    if (results.length === 0) return null;\n    \n    return this.deserializeNode(results[0]!);\n  }\n  \n  async getNodes(ids: string[]): Promise<Node[]> {\n    if (ids.length === 0) return [];\n    \n    const placeholders = ids.map(() => '?').join(',');\n    const query = `SELECT * FROM kg_nodes WHERE id IN (${placeholders})`;\n    const results = await this.execute<Record<string, unknown>>(query, ids);\n    \n    return results.map(n => this.deserializeNode(n));\n  }\n  \n  async queryNodes(conditions: Record<string, unknown>, limit = 100, offset = 0): Promise<Node[]> {\n    const whereClauses: string[] = [];\n    const params: unknown[] = [];\n    \n    for (const [key, value] of Object.entries(conditions)) {\n      whereClauses.push(`${key} = ?`);\n      params.push(value);\n    }\n    \n    params.push(limit, offset);\n    \n    const query = `\n      SELECT * FROM kg_nodes \n      ${whereClauses.length > 0 ? 'WHERE ' + whereClauses.join(' AND ') : ''}\n      LIMIT ? OFFSET ?\n    `;\n    \n    const results = await this.execute<Record<string, unknown>>(query, params);\n    return results.map(n => this.deserializeNode(n));\n  }\n  \n  // Edge operations\n  async insertEdge(edge: NewEdge): Promise<Edge> {\n    const id = edge.id || crypto.randomUUID();\n    const now = Date.now();\n    \n    const query = `\n      INSERT INTO kg_edges (id, type, from_node_id, to_node_id, properties, confidence, created_at, source_session_ids)\n      VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n    `;\n    \n    await this.execute(query, [\n      id,\n      edge.type,\n      edge.fromNodeId,\n      edge.toNodeId,\n      JSON.stringify(edge.properties || {}),\n      edge.confidence || 1.0,\n      edge.createdAt?.getTime() || now,\n      edge.sourceSessionIds ? JSON.stringify(edge.sourceSessionIds) : null\n    ]);\n    \n    return this.getEdge(id) as Promise<Edge>;\n  }\n  \n  async updateEdge(id: string, updates: Partial<NewEdge>): Promise<Edge | null> {\n    const setClauses: string[] = [];\n    const params: unknown[] = [];\n    \n    if (updates.type !== undefined) {\n      setClauses.push('type = ?');\n      params.push(updates.type);\n    }\n    if (updates.fromNodeId !== undefined) {\n      setClauses.push('from_node_id = ?');\n      params.push(updates.fromNodeId);\n    }\n    if (updates.toNodeId !== undefined) {\n      setClauses.push('to_node_id = ?');\n      params.push(updates.toNodeId);\n    }\n    if (updates.properties !== undefined) {\n      setClauses.push('properties = ?');\n      params.push(JSON.stringify(updates.properties));\n    }\n    if (updates.confidence !== undefined) {\n      setClauses.push('confidence = ?');\n      params.push(updates.confidence);\n    }\n    if (updates.sourceSessionIds !== undefined) {\n      setClauses.push('source_session_ids = ?');\n      params.push(JSON.stringify(updates.sourceSessionIds));\n    }\n    \n    params.push(id);\n    \n    const query = `UPDATE kg_edges SET ${setClauses.join(', ')} WHERE id = ?`;\n    await this.execute(query, params);\n    \n    return this.getEdge(id);\n  }\n  \n  async deleteEdge(id: string): Promise<boolean> {\n    const query = `DELETE FROM kg_edges WHERE id = ?`;\n    await this.execute(query, [id]);\n    return true;\n  }\n  \n  async getEdge(id: string): Promise<Edge | null> {\n    const query = `SELECT * FROM kg_edges WHERE id = ? LIMIT 1`;\n    const results = await this.execute<Record<string, unknown>>(query, [id]);\n    \n    if (results.length === 0) return null;\n    \n    return this.deserializeEdge(results[0]!);\n  }\n  \n  async getEdges(ids: string[]): Promise<Edge[]> {\n    if (ids.length === 0) return [];\n    \n    const placeholders = ids.map(() => '?').join(',');\n    const query = `SELECT * FROM kg_edges WHERE id IN (${placeholders})`;\n    const results = await this.execute<Record<string, unknown>>(query, ids);\n    \n    return results.map(e => this.deserializeEdge(e));\n  }\n  \n  async queryEdges(conditions: Record<string, unknown>, limit = 100, offset = 0): Promise<Edge[]> {\n    const whereClauses: string[] = [];\n    const params: unknown[] = [];\n    \n    // Map camelCase to snake_case for query conditions\n    const fieldMap: Record<string, string> = {\n      'fromNodeId': 'from_node_id',\n      'toNodeId': 'to_node_id',\n      'from_node_id': 'from_node_id',\n      'to_node_id': 'to_node_id',\n      'createdAt': 'created_at',\n      'updatedAt': 'updated_at',\n      'sourceSessionIds': 'source_session_ids'\n    };\n    \n    for (const [key, value] of Object.entries(conditions)) {\n      const dbKey = fieldMap[key] || key;\n      whereClauses.push(`${dbKey} = ?`);\n      params.push(value);\n    }\n    \n    params.push(limit, offset);\n    \n    const query = `\n      SELECT * FROM kg_edges \n      ${whereClauses.length > 0 ? 'WHERE ' + whereClauses.join(' AND ') : ''}\n      LIMIT ? OFFSET ?\n    `;\n    \n    const results = await this.execute<Record<string, unknown>>(query, params);\n    return results.map(e => this.deserializeEdge(e));\n  }\n  \n  // Index operations\n  async insertNodeIndex(index: NewNodeIndex): Promise<NodeIndex> {\n    const query = `\n      INSERT INTO kg_node_indices (index_key, node_id, created_at)\n      VALUES (?, ?, ?)\n    `;\n    \n    await this.execute(query, [\n      index.indexKey,\n      index.nodeId,\n      index.createdAt?.getTime() || Date.now()\n    ]);\n    \n    return index as NodeIndex;\n  }\n  \n  async deleteNodeIndex(indexKey: string, nodeId?: string): Promise<number> {\n    const query = nodeId\n      ? `DELETE FROM kg_node_indices WHERE index_key = ? AND node_id = ?`\n      : `DELETE FROM kg_node_indices WHERE index_key = ?`;\n    const params = nodeId ? [indexKey, nodeId] : [indexKey];\n    \n    await this.execute(query, params);\n    return 1; // D1 doesn't provide change count easily\n  }\n  \n  async getNodeIndices(indexKey: string): Promise<NodeIndex[]> {\n    const query = `SELECT * FROM kg_node_indices WHERE index_key = ?`;\n    const results = await this.execute<Record<string, unknown>>(query, [indexKey]);\n    return results.map(r => this.deserializeNodeIndex(r));\n  }\n  \n  async insertEdgeIndex(index: NewEdgeIndex): Promise<EdgeIndex> {\n    const query = `\n      INSERT INTO kg_edge_indices (index_key, edge_id, created_at)\n      VALUES (?, ?, ?)\n    `;\n    \n    await this.execute(query, [\n      index.indexKey,\n      index.edgeId,\n      index.createdAt?.getTime() || Date.now()\n    ]);\n    \n    return index as EdgeIndex;\n  }\n  \n  async deleteEdgeIndex(indexKey: string, edgeId?: string): Promise<number> {\n    const query = edgeId\n      ? `DELETE FROM kg_edge_indices WHERE index_key = ? AND edge_id = ?`\n      : `DELETE FROM kg_edge_indices WHERE index_key = ?`;\n    const params = edgeId ? [indexKey, edgeId] : [indexKey];\n    \n    await this.execute(query, params);\n    return 1;\n  }\n  \n  async getEdgeIndices(indexKey: string): Promise<EdgeIndex[]> {\n    const query = `SELECT * FROM kg_edge_indices WHERE index_key = ?`;\n    const results = await this.execute<Record<string, unknown>>(query, [indexKey]);\n    return results.map(r => this.deserializeEdgeIndex(r));\n  }\n  \n  // Search operations\n  async insertSearchIndex(index: NewSearchIndex): Promise<SearchIndex> {\n    const query = `\n      INSERT OR REPLACE INTO kg_search_index (term, node_id, field, weight)\n      VALUES (?, ?, ?, ?)\n    `;\n    \n    await this.execute(query, [\n      index.term,\n      index.nodeId,\n      index.field,\n      index.weight || 1.0\n    ]);\n    \n    return index as SearchIndex;\n  }\n  \n  async deleteSearchIndex(nodeId: string): Promise<number> {\n    const query = `DELETE FROM kg_search_index WHERE node_id = ?`;\n    await this.execute(query, [nodeId]);\n    return 1;\n  }\n  \n  async searchNodes(term: string, limit = 50): Promise<SearchIndex[]> {\n    const query = `\n      SELECT * FROM kg_search_index \n      WHERE term LIKE ? \n      ORDER BY weight DESC \n      LIMIT ?\n    `;\n    \n    const results = await this.execute<Record<string, unknown>>(query, [`%${term}%`, limit]);\n    return results.map(r => this.deserializeSearchIndex(r));\n  }\n  \n  // Batch operations\n  async batchInsertNodes(nodes: NewNode[]): Promise<Node[]> {\n    const insertedNodes: Node[] = [];\n    \n    for (const node of nodes) {\n      const inserted = await this.insertNode(node);\n      insertedNodes.push(inserted);\n    }\n    \n    return insertedNodes;\n  }\n  \n  async batchInsertEdges(edges: NewEdge[]): Promise<Edge[]> {\n    const insertedEdges: Edge[] = [];\n    \n    for (const edge of edges) {\n      const inserted = await this.insertEdge(edge);\n      insertedEdges.push(inserted);\n    }\n    \n    return insertedEdges;\n  }\n  \n  async batchDeleteNodes(ids: string[]): Promise<number> {\n    if (ids.length === 0) return 0;\n    \n    const placeholders = ids.map(() => '?').join(',');\n    const query = `DELETE FROM kg_nodes WHERE id IN (${placeholders})`;\n    await this.execute(query, ids);\n    return ids.length;\n  }\n  \n  async batchDeleteEdges(ids: string[]): Promise<number> {\n    if (ids.length === 0) return 0;\n    \n    const placeholders = ids.map(() => '?').join(',');\n    const query = `DELETE FROM kg_edges WHERE id IN (${placeholders})`;\n    await this.execute(query, ids);\n    return ids.length;\n  }\n  \n  // Maintenance operations\n  async vacuum(): Promise<void> {\n    // D1 handles vacuum automatically\n    this.log('Vacuum not needed for D1 (handled automatically)');\n  }\n  \n  async getStats(): Promise<DatabaseStats> {\n    const nodeCount = await this.execute<{count: number}>('SELECT COUNT(*) as count FROM kg_nodes');\n    const edgeCount = await this.execute<{count: number}>('SELECT COUNT(*) as count FROM kg_edges');\n    const indexCount = await this.execute<{count: number}>('SELECT COUNT(*) as count FROM kg_node_indices');\n    \n    return {\n      nodeCount: nodeCount[0]?.count || 0,\n      edgeCount: edgeCount[0]?.count || 0,\n      indexCount: indexCount[0]?.count || 0,\n    };\n  }\n  \n  async close(): Promise<void> {\n    // D1 doesn't need explicit close\n    this.db = null;\n    this.log('D1 adapter closed');\n  }\n  \n  // Helper methods\n  private deserializeNode(row: Record<string, unknown>): Node {\n    return {\n      id: row.id as string,\n      type: row.type as string,\n      label: row.label as string,\n      properties: typeof row.properties === 'string' ? JSON.parse(row.properties) : row.properties || {},\n      confidence: row.confidence as number,\n      createdAt: new Date(row.created_at as string | number),\n      updatedAt: new Date(row.updated_at as string | number),\n      sourceSessionIds: row.source_session_ids ? JSON.parse(row.source_session_ids as string) : undefined,\n    };\n  }\n  \n  private deserializeEdge(row: Record<string, unknown>): Edge {\n    return {\n      id: row.id as string,\n      type: row.type as string,\n      fromNodeId: row.from_node_id as string,\n      toNodeId: row.to_node_id as string,\n      properties: typeof row.properties === 'string' ? JSON.parse(row.properties) : row.properties || {},\n      confidence: row.confidence as number,\n      createdAt: new Date(row.created_at as string | number),\n      sourceSessionIds: row.source_session_ids ? JSON.parse(row.source_session_ids as string) : undefined,\n    };\n  }\n  \n  private deserializeNodeIndex(row: Record<string, unknown>): NodeIndex {\n    return {\n      indexKey: row.index_key as string,\n      nodeId: row.node_id as string,\n      createdAt: new Date(row.created_at as string | number),\n    };\n  }\n  \n  private deserializeEdgeIndex(row: Record<string, unknown>): EdgeIndex {\n    return {\n      indexKey: row.index_key as string,\n      edgeId: row.edge_id as string,\n      createdAt: new Date(row.created_at as string | number),\n    };\n  }\n  \n  private deserializeSearchIndex(row: Record<string, unknown>): SearchIndex {\n    return {\n      term: row.term as string,\n      nodeId: row.node_id as string,\n      field: row.field as string,\n      weight: row.weight as number,\n    };\n  }\n}","import { BaseAdapter, TransactionContext, DatabaseStats, AdapterConfig } from './base';\nimport type { Node, Edge, NodeIndex, EdgeIndex, SearchIndex, NewNode, NewEdge, NewNodeIndex, NewEdgeIndex, NewSearchIndex } from '../schema';\n\n/**\n * SqlStorage interface - matches the browser's SqlStorage API\n */\ninterface SqlStorage {\n  exec(query: string, ...params: any[]): {\n    toArray(): any[];\n    rowsWritten?: number;\n  };\n}\n\n/**\n * SqlStorage adapter for browser environments\n * Works with browser-based SQL storage implementations\n */\nexport class SqlStorageAdapter extends BaseAdapter {\n  private sql: SqlStorage | null = null;\n\n  constructor(config: AdapterConfig = {}) {\n    super(config);\n  }\n\n  /**\n   * Set the SqlStorage instance\n   * Must be called before using the adapter\n   */\n  setSqlStorage(sql: SqlStorage): void {\n    this.sql = sql;\n  }\n\n  async initialize(): Promise<void> {\n    if (!this.sql) {\n      throw new Error('SqlStorage not set. Call setSqlStorage() first.');\n    }\n\n    try {\n      if (this.config.autoCreate !== false) {\n        await this.createTables();\n      }\n\n      this.log('SqlStorage adapter initialized');\n    } catch (error) {\n      this.error('Failed to initialize SqlStorage adapter', error);\n      throw error;\n    }\n  }\n\n  private async createTables(): Promise<void> {\n    if (!this.sql) throw new Error('SqlStorage not initialized');\n\n    // Create nodes table\n    this.sql.exec(`\n      CREATE TABLE IF NOT EXISTS kg_nodes (\n        id TEXT PRIMARY KEY,\n        type TEXT NOT NULL,\n        label TEXT NOT NULL,\n        properties TEXT NOT NULL DEFAULT '{}',\n        confidence REAL NOT NULL DEFAULT 1.0,\n        created_at INTEGER NOT NULL,\n        updated_at INTEGER NOT NULL,\n        source_session_ids TEXT\n      )\n    `);\n    this.sql.exec(`CREATE INDEX IF NOT EXISTS idx_nodes_type ON kg_nodes(type)`);\n    this.sql.exec(`CREATE INDEX IF NOT EXISTS idx_nodes_label ON kg_nodes(label)`);\n    this.sql.exec(`CREATE INDEX IF NOT EXISTS idx_nodes_created_at ON kg_nodes(created_at)`);\n\n    // Create edges table\n    this.sql.exec(`\n      CREATE TABLE IF NOT EXISTS kg_edges (\n        id TEXT PRIMARY KEY,\n        type TEXT NOT NULL,\n        from_node_id TEXT NOT NULL REFERENCES kg_nodes(id) ON DELETE CASCADE,\n        to_node_id TEXT NOT NULL REFERENCES kg_nodes(id) ON DELETE CASCADE,\n        properties TEXT NOT NULL DEFAULT '{}',\n        confidence REAL NOT NULL DEFAULT 1.0,\n        created_at INTEGER NOT NULL,\n        source_session_ids TEXT\n      )\n    `);\n    this.sql.exec(`CREATE INDEX IF NOT EXISTS idx_edges_type ON kg_edges(type)`);\n    this.sql.exec(`CREATE INDEX IF NOT EXISTS idx_edges_from_node ON kg_edges(from_node_id)`);\n    this.sql.exec(`CREATE INDEX IF NOT EXISTS idx_edges_to_node ON kg_edges(to_node_id)`);\n    this.sql.exec(`CREATE INDEX IF NOT EXISTS idx_edges_from_type ON kg_edges(from_node_id, type)`);\n    this.sql.exec(`CREATE INDEX IF NOT EXISTS idx_edges_to_type ON kg_edges(to_node_id, type)`);\n\n    // Create node indices table\n    this.sql.exec(`\n      CREATE TABLE IF NOT EXISTS kg_node_indices (\n        index_key TEXT NOT NULL,\n        node_id TEXT NOT NULL REFERENCES kg_nodes(id) ON DELETE CASCADE,\n        created_at INTEGER NOT NULL,\n        PRIMARY KEY (index_key, node_id)\n      )\n    `);\n    this.sql.exec(`CREATE INDEX IF NOT EXISTS idx_node_indices_key ON kg_node_indices(index_key)`);\n    this.sql.exec(`CREATE INDEX IF NOT EXISTS idx_node_indices_node ON kg_node_indices(node_id)`);\n\n    // Create edge indices table\n    this.sql.exec(`\n      CREATE TABLE IF NOT EXISTS kg_edge_indices (\n        index_key TEXT NOT NULL,\n        edge_id TEXT NOT NULL REFERENCES kg_edges(id) ON DELETE CASCADE,\n        created_at INTEGER NOT NULL,\n        PRIMARY KEY (index_key, edge_id)\n      )\n    `);\n    this.sql.exec(`CREATE INDEX IF NOT EXISTS idx_edge_indices_key ON kg_edge_indices(index_key)`);\n    this.sql.exec(`CREATE INDEX IF NOT EXISTS idx_edge_indices_edge ON kg_edge_indices(edge_id)`);\n\n    // Create search index table\n    this.sql.exec(`\n      CREATE TABLE IF NOT EXISTS kg_search_index (\n        term TEXT NOT NULL,\n        node_id TEXT NOT NULL REFERENCES kg_nodes(id) ON DELETE CASCADE,\n        field TEXT NOT NULL,\n        weight REAL NOT NULL DEFAULT 1.0,\n        PRIMARY KEY (term, node_id, field)\n      )\n    `);\n    this.sql.exec(`CREATE INDEX IF NOT EXISTS idx_search_term ON kg_search_index(term)`);\n    this.sql.exec(`CREATE INDEX IF NOT EXISTS idx_search_node ON kg_search_index(node_id)`);\n\n    // Create graph metadata table\n    this.sql.exec(`\n      CREATE TABLE IF NOT EXISTS kg_graph_metadata (\n        key TEXT PRIMARY KEY,\n        value TEXT NOT NULL,\n        updated_at INTEGER NOT NULL\n      )\n    `);\n  }\n\n  async execute<T = unknown>(query: string, params: any[] = []): Promise<T[]> {\n    if (!this.sql) throw new Error('SqlStorage not initialized');\n\n    try {\n      const result = this.sql.exec(query, ...params);\n      return result.toArray() as T[];\n    } catch (error) {\n      this.error('Query execution failed', { query, params, error });\n      throw error;\n    }\n  }\n\n  async transaction<T>(fn: (tx: TransactionContext) => Promise<T>): Promise<T> {\n    if (!this.sql) throw new Error('SqlStorage not initialized');\n\n    // SqlStorage doesn't have native transaction support\n    // We'll execute operations directly\n    const tx: TransactionContext = {\n      execute: async <U = unknown>(query: string, params: any[] = []): Promise<U[]> => {\n        return this.execute<U>(query, params);\n      },\n      rollback: async () => {\n        throw new Error('SqlStorage does not support transaction rollback');\n      },\n    };\n\n    try {\n      return await fn(tx);\n    } catch (error) {\n      this.error('Transaction failed', error);\n      throw error;\n    }\n  }\n\n  // Node operations\n  async insertNode(node: NewNode): Promise<Node> {\n    const now = Date.now();\n    const id = node.id || this.generateId();\n    const properties = JSON.stringify(node.properties || {});\n    const sourceSessionIds = node.sourceSessionIds ? JSON.stringify(node.sourceSessionIds) : null;\n\n    const query = `\n      INSERT INTO kg_nodes (id, type, label, properties, confidence, created_at, updated_at, source_session_ids)\n      VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n    `;\n\n    await this.execute(query, [\n      id,\n      node.type,\n      node.label,\n      properties,\n      node.confidence || 1.0,\n      node.createdAt?.getTime() || now,\n      node.updatedAt?.getTime() || now,\n      sourceSessionIds,\n    ]);\n\n    const result = await this.getNode(id);\n    if (!result) throw new Error('Failed to create node');\n    return result;\n  }\n\n  async updateNode(id: string, updates: Partial<NewNode>): Promise<Node | null> {\n    const current = await this.getNode(id);\n    if (!current) return null;\n\n    const setClauses: string[] = [];\n    const params: any[] = [];\n\n    if (updates.type !== undefined) {\n      setClauses.push('type = ?');\n      params.push(updates.type);\n    }\n    if (updates.label !== undefined) {\n      setClauses.push('label = ?');\n      params.push(updates.label);\n    }\n    if (updates.properties !== undefined) {\n      setClauses.push('properties = ?');\n      params.push(JSON.stringify(updates.properties));\n    }\n    if (updates.confidence !== undefined) {\n      setClauses.push('confidence = ?');\n      params.push(updates.confidence);\n    }\n    if (updates.sourceSessionIds !== undefined) {\n      setClauses.push('source_session_ids = ?');\n      params.push(JSON.stringify(updates.sourceSessionIds));\n    }\n\n    setClauses.push('updated_at = ?');\n    params.push(Date.now());\n\n    params.push(id);\n\n    const query = `UPDATE kg_nodes SET ${setClauses.join(', ')} WHERE id = ?`;\n    await this.execute(query, params);\n\n    return this.getNode(id);\n  }\n\n  async deleteNode(id: string): Promise<boolean> {\n    const query = `DELETE FROM kg_nodes WHERE id = ?`;\n    const result = await this.execute(query, [id]);\n    return Array.isArray(result) || result !== undefined;\n  }\n\n  async getNode(id: string): Promise<Node | null> {\n    const query = `SELECT * FROM kg_nodes WHERE id = ? LIMIT 1`;\n    const result = await this.execute<any>(query, [id]);\n    \n    if (!result || result.length === 0) return null;\n    \n    return this.deserializeNode(result[0]);\n  }\n\n  async getNodes(ids: string[]): Promise<Node[]> {\n    if (ids.length === 0) return [];\n\n    const placeholders = ids.map(() => '?').join(',');\n    const query = `SELECT * FROM kg_nodes WHERE id IN (${placeholders})`;\n    const result = await this.execute<any>(query, ids);\n    \n    return result.map((n: any) => this.deserializeNode(n));\n  }\n\n  async queryNodes(conditions: Record<string, any>, limit = 100, offset = 0): Promise<Node[]> {\n    const whereClauses: string[] = [];\n    const params: any[] = [];\n\n    Object.entries(conditions).forEach(([key, value]) => {\n      whereClauses.push(`${key} = ?`);\n      params.push(value);\n    });\n\n    params.push(limit, offset);\n\n    const query = `\n      SELECT * FROM kg_nodes\n      ${whereClauses.length > 0 ? `WHERE ${whereClauses.join(' AND ')}` : ''}\n      LIMIT ? OFFSET ?\n    `;\n\n    const result = await this.execute<any>(query, params);\n    return result.map((n: any) => this.deserializeNode(n));\n  }\n\n  // Edge operations\n  async insertEdge(edge: NewEdge): Promise<Edge> {\n    const now = Date.now();\n    const id = edge.id || this.generateId();\n    const properties = JSON.stringify(edge.properties || {});\n    const sourceSessionIds = edge.sourceSessionIds ? JSON.stringify(edge.sourceSessionIds) : null;\n\n    const query = `\n      INSERT INTO kg_edges (id, type, from_node_id, to_node_id, properties, confidence, created_at, source_session_ids)\n      VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n    `;\n\n    await this.execute(query, [\n      id,\n      edge.type,\n      edge.fromNodeId,\n      edge.toNodeId,\n      properties,\n      edge.confidence || 1.0,\n      edge.createdAt?.getTime() || now,\n      sourceSessionIds,\n    ]);\n\n    const result = await this.getEdge(id);\n    if (!result) throw new Error('Failed to create edge');\n    return result;\n  }\n\n  async updateEdge(id: string, updates: Partial<NewEdge>): Promise<Edge | null> {\n    const current = await this.getEdge(id);\n    if (!current) return null;\n\n    const setClauses: string[] = [];\n    const params: any[] = [];\n\n    if (updates.type !== undefined) {\n      setClauses.push('type = ?');\n      params.push(updates.type);\n    }\n    if (updates.fromNodeId !== undefined) {\n      setClauses.push('from_node_id = ?');\n      params.push(updates.fromNodeId);\n    }\n    if (updates.toNodeId !== undefined) {\n      setClauses.push('to_node_id = ?');\n      params.push(updates.toNodeId);\n    }\n    if (updates.properties !== undefined) {\n      setClauses.push('properties = ?');\n      params.push(JSON.stringify(updates.properties));\n    }\n    if (updates.confidence !== undefined) {\n      setClauses.push('confidence = ?');\n      params.push(updates.confidence);\n    }\n    if (updates.sourceSessionIds !== undefined) {\n      setClauses.push('source_session_ids = ?');\n      params.push(JSON.stringify(updates.sourceSessionIds));\n    }\n\n    params.push(id);\n\n    const query = `UPDATE kg_edges SET ${setClauses.join(', ')} WHERE id = ?`;\n    await this.execute(query, params);\n\n    return this.getEdge(id);\n  }\n\n  async deleteEdge(id: string): Promise<boolean> {\n    const query = `DELETE FROM kg_edges WHERE id = ?`;\n    await this.execute(query, [id]);\n    return true;\n  }\n\n  async getEdge(id: string): Promise<Edge | null> {\n    const query = `SELECT * FROM kg_edges WHERE id = ? LIMIT 1`;\n    const result = await this.execute<any>(query, [id]);\n    \n    if (!result || result.length === 0) return null;\n    \n    return this.deserializeEdge(result[0]);\n  }\n\n  async getEdges(ids: string[]): Promise<Edge[]> {\n    if (ids.length === 0) return [];\n\n    const placeholders = ids.map(() => '?').join(',');\n    const query = `SELECT * FROM kg_edges WHERE id IN (${placeholders})`;\n    const result = await this.execute<any>(query, ids);\n    \n    return result.map((e: any) => this.deserializeEdge(e));\n  }\n\n  async queryEdges(conditions: Record<string, any>, limit = 100, offset = 0): Promise<Edge[]> {\n    const whereClauses: string[] = [];\n    const params: any[] = [];\n\n    Object.entries(conditions).forEach(([key, value]) => {\n      // Convert camelCase to snake_case for database column names\n      const dbKey = key === 'fromNodeId' ? 'from_node_id' : \n                    key === 'toNodeId' ? 'to_node_id' : \n                    key;\n      whereClauses.push(`${dbKey} = ?`);\n      params.push(value);\n    });\n\n    params.push(limit, offset);\n\n    const query = `\n      SELECT * FROM kg_edges\n      ${whereClauses.length > 0 ? `WHERE ${whereClauses.join(' AND ')}` : ''}\n      LIMIT ? OFFSET ?\n    `;\n\n    const result = await this.execute<any>(query, params);\n    return result.map((e: any) => this.deserializeEdge(e));\n  }\n\n  // Index operations\n  async insertNodeIndex(index: NewNodeIndex): Promise<NodeIndex> {\n    const now = Date.now();\n    const query = `\n      INSERT INTO kg_node_indices (index_key, node_id, created_at)\n      VALUES (?, ?, ?)\n    `;\n\n    await this.execute(query, [index.indexKey, index.nodeId, index.createdAt?.getTime() || now]);\n\n    return {\n      ...index,\n      createdAt: index.createdAt || new Date(now),\n    };\n  }\n\n  async deleteNodeIndex(indexKey: string, nodeId?: string): Promise<number> {\n    const query = nodeId\n      ? `DELETE FROM kg_node_indices WHERE index_key = ? AND node_id = ?`\n      : `DELETE FROM kg_node_indices WHERE index_key = ?`;\n    const params = nodeId ? [indexKey, nodeId] : [indexKey];\n\n    const result = await this.execute(query, params);\n    return Array.isArray(result) ? result.length : 0;\n  }\n\n  async getNodeIndices(indexKey: string): Promise<NodeIndex[]> {\n    const query = `SELECT * FROM kg_node_indices WHERE index_key = ?`;\n    const result = await this.execute<any>(query, [indexKey]);\n    \n    return result.map((idx: any) => ({\n      indexKey: idx.index_key,\n      nodeId: idx.node_id,\n      createdAt: new Date(idx.created_at),\n    }));\n  }\n\n  async insertEdgeIndex(index: NewEdgeIndex): Promise<EdgeIndex> {\n    const now = Date.now();\n    const query = `\n      INSERT INTO kg_edge_indices (index_key, edge_id, created_at)\n      VALUES (?, ?, ?)\n    `;\n\n    await this.execute(query, [index.indexKey, index.edgeId, index.createdAt?.getTime() || now]);\n\n    return {\n      ...index,\n      createdAt: index.createdAt || new Date(now),\n    };\n  }\n\n  async deleteEdgeIndex(indexKey: string, edgeId?: string): Promise<number> {\n    const query = edgeId\n      ? `DELETE FROM kg_edge_indices WHERE index_key = ? AND edge_id = ?`\n      : `DELETE FROM kg_edge_indices WHERE index_key = ?`;\n    const params = edgeId ? [indexKey, edgeId] : [indexKey];\n\n    const result = await this.execute(query, params);\n    return Array.isArray(result) ? result.length : 0;\n  }\n\n  async getEdgeIndices(indexKey: string): Promise<EdgeIndex[]> {\n    const query = `SELECT * FROM kg_edge_indices WHERE index_key = ?`;\n    const result = await this.execute<any>(query, [indexKey]);\n    \n    return result.map((idx: any) => ({\n      indexKey: idx.index_key,\n      edgeId: idx.edge_id,\n      createdAt: new Date(idx.created_at),\n    }));\n  }\n\n  // Search operations\n  async insertSearchIndex(index: NewSearchIndex): Promise<SearchIndex> {\n    const query = `\n      INSERT OR REPLACE INTO kg_search_index (term, node_id, field, weight)\n      VALUES (?, ?, ?, ?)\n    `;\n\n    await this.execute(query, [index.term, index.nodeId, index.field, index.weight || 1.0]);\n\n    return {\n      ...index,\n      weight: index.weight || 1.0,\n    };\n  }\n\n  async deleteSearchIndex(nodeId: string): Promise<number> {\n    const query = `DELETE FROM kg_search_index WHERE node_id = ?`;\n    const result = await this.execute(query, [nodeId]);\n    return Array.isArray(result) ? result.length : 0;\n  }\n\n  async searchNodes(term: string, limit = 50): Promise<SearchIndex[]> {\n    const query = `\n      SELECT * FROM kg_search_index\n      WHERE term LIKE ?\n      LIMIT ?\n    `;\n    const result = await this.execute<any>(query, [`%${term}%`, limit]);\n    \n    return result.map((idx: any) => ({\n      term: idx.term,\n      nodeId: idx.node_id,\n      field: idx.field,\n      weight: idx.weight,\n    }));\n  }\n\n  // Batch operations\n  async batchInsertNodes(nodes: NewNode[]): Promise<Node[]> {\n    const results: Node[] = [];\n    \n    for (const node of nodes) {\n      const inserted = await this.insertNode(node);\n      results.push(inserted);\n    }\n    \n    return results;\n  }\n\n  async batchInsertEdges(edges: NewEdge[]): Promise<Edge[]> {\n    const results: Edge[] = [];\n    \n    for (const edge of edges) {\n      const inserted = await this.insertEdge(edge);\n      results.push(inserted);\n    }\n    \n    return results;\n  }\n\n  async batchDeleteNodes(ids: string[]): Promise<number> {\n    if (ids.length === 0) return 0;\n\n    const placeholders = ids.map(() => '?').join(',');\n    const query = `DELETE FROM kg_nodes WHERE id IN (${placeholders})`;\n    const result = await this.execute(query, ids);\n    return Array.isArray(result) ? result.length : ids.length;\n  }\n\n  async batchDeleteEdges(ids: string[]): Promise<number> {\n    if (ids.length === 0) return 0;\n\n    const placeholders = ids.map(() => '?').join(',');\n    const query = `DELETE FROM kg_edges WHERE id IN (${placeholders})`;\n    const result = await this.execute(query, ids);\n    return Array.isArray(result) ? result.length : ids.length;\n  }\n\n  // Maintenance operations\n  async vacuum(): Promise<void> {\n    if (!this.sql) throw new Error('SqlStorage not initialized');\n\n    try {\n      this.sql.exec('VACUUM');\n      this.log('Database vacuumed');\n    } catch {\n      // SqlStorage might not support VACUUM\n      this.log('VACUUM not supported by SqlStorage');\n    }\n  }\n\n  async getStats(): Promise<DatabaseStats> {\n    const nodeCountResult = await this.execute<any>('SELECT COUNT(*) as count FROM kg_nodes');\n    const edgeCountResult = await this.execute<any>('SELECT COUNT(*) as count FROM kg_edges');\n    const indexCountResult = await this.execute<any>('SELECT COUNT(*) as count FROM kg_node_indices');\n\n    return {\n      nodeCount: nodeCountResult[0]?.count || 0,\n      edgeCount: edgeCountResult[0]?.count || 0,\n      indexCount: indexCountResult[0]?.count || 0,\n    };\n  }\n\n  async close(): Promise<void> {\n    this.sql = null;\n    this.log('SqlStorage adapter closed');\n  }\n\n  // Helper methods\n  private generateId(): string {\n    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private deserializeNode(node: any): Node {\n    return {\n      id: node.id,\n      type: node.type,\n      label: node.label,\n      properties: typeof node.properties === 'string' ? JSON.parse(node.properties) : node.properties,\n      confidence: node.confidence,\n      createdAt: new Date(node.created_at),\n      updatedAt: new Date(node.updated_at),\n      sourceSessionIds: node.source_session_ids \n        ? (typeof node.source_session_ids === 'string' ? JSON.parse(node.source_session_ids) : node.source_session_ids)\n        : undefined,\n    };\n  }\n\n  private deserializeEdge(edge: any): Edge {\n    return {\n      id: edge.id,\n      type: edge.type,\n      fromNodeId: edge.from_node_id,\n      toNodeId: edge.to_node_id,\n      properties: typeof edge.properties === 'string' ? JSON.parse(edge.properties) : edge.properties,\n      confidence: edge.confidence,\n      createdAt: new Date(edge.created_at),\n      sourceSessionIds: edge.source_session_ids\n        ? (typeof edge.source_session_ids === 'string' ? JSON.parse(edge.source_session_ids) : edge.source_session_ids)\n        : undefined,\n    };\n  }\n}","export type { DatabaseAdapter, AdapterConfig, TransactionContext, DatabaseStats } from './base';\nexport { BaseAdapter } from './base';\nexport { SQLiteAdapter } from './sqlite';\nexport { D1Adapter } from './d1';\nexport { SqlStorageAdapter } from './sql-storage';\n\nimport type { DatabaseAdapter, AdapterConfig } from './base';\nimport { SQLiteAdapter } from './sqlite';\nimport { D1Adapter } from './d1';\nimport { SqlStorageAdapter } from './sql-storage';\n\n// Factory function to create appropriate adapter\nexport async function createAdapter(type: 'sqlite' | 'd1' | 'libsql' | 'sql-storage', config?: AdapterConfig): Promise<DatabaseAdapter> {\n  switch (type) {\n    case 'sqlite':\n      // For now, always use better-sqlite3 adapter\n      // Bun support will be added in a future release\n      return new SQLiteAdapter(config);\n    case 'd1':\n      return new D1Adapter(config || {});\n    case 'sql-storage':\n      return new SqlStorageAdapter(config || {});\n    case 'libsql':\n      // TODO: Implement LibSQL adapter\n      throw new Error('LibSQL adapter not yet implemented');\n    default:\n      throw new Error(`Unknown adapter type: ${type}`);\n  }\n}\n","import { KnowledgeGraph } from '../core/KnowledgeGraph';\nimport { NodeType, CommonEdgeType, ExtractedKnowledge, ExtractedNodeData, ExtractedEdgeData } from '../types';\n\n/**\n * Options for knowledge extraction\n */\nexport interface ExtractionOptions {\n  minConfidence?: number;\n  extractEntities?: boolean;\n  extractRelationships?: boolean;\n  extractTopics?: boolean;\n  extractSentiment?: boolean;\n  mergeStrategy?: 'replace' | 'merge' | 'skip';\n  sessionId?: string;\n}\n\n/**\n * Entity pattern for extraction\n */\nexport interface EntityPattern {\n  pattern: RegExp;\n  type: string;\n  extractor?: (match: RegExpMatchArray) => Partial<ExtractedNodeData>;\n}\n\n/**\n * Relationship pattern for extraction\n */\nexport interface RelationshipPattern {\n  pattern: RegExp;\n  type: string;\n  extractor?: (match: RegExpMatchArray, nodes: Map<string, ExtractedNodeData>) => Partial<ExtractedEdgeData>;\n}\n\n/**\n * Knowledge extraction service\n */\nexport class KnowledgeExtractor {\n  private graph: KnowledgeGraph;\n  private entityPatterns: EntityPattern[] = [];\n  private relationshipPatterns: RelationshipPattern[] = [];\n\n  constructor(graph: KnowledgeGraph) {\n    this.graph = graph;\n    this.setupDefaultPatterns();\n  }\n\n  /**\n   * Setup default extraction patterns\n   */\n  private setupDefaultPatterns(): void {\n    // Email patterns\n    this.entityPatterns.push({\n      pattern: /\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b/g,\n      type: 'PERSON',\n      extractor: (match) => ({\n        label: match[0],\n        properties: { type: 'email', value: match[0] },\n      }),\n    });\n\n    // URL patterns\n    this.entityPatterns.push({\n      pattern: /https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_+.~#?&//=]*)/g,\n      type: 'DOCUMENT',\n      extractor: (match) => ({\n        label: new URL(match[0]).hostname,\n        properties: { url: match[0], type: 'website' },\n      }),\n    });\n\n    // Phone number patterns\n    this.entityPatterns.push({\n      pattern: /(\\+\\d{1,3}[-.\\s]?)?\\(?\\d{1,4}\\)?[-.\\s]?\\d{1,4}[-.\\s]?\\d{1,9}/g,\n      type: 'PERSON',\n      extractor: (match) => ({\n        label: match[0],\n        properties: { type: 'phone', value: match[0] },\n      }),\n    });\n\n    // Date patterns\n    this.entityPatterns.push({\n      pattern: /\\b(\\d{1,2})[/-](\\d{1,2})[/-](\\d{2,4})\\b/g,\n      type: 'EVENT',\n      extractor: (match) => ({\n        label: match[0],\n        properties: { type: 'date', value: match[0] },\n      }),\n    });\n\n    // Money patterns\n    this.entityPatterns.push({\n      pattern: /[$]\\s?\\d+(?:,\\d{3})*(?:\\.\\d{2})?/g,\n      type: 'FINANCIAL',\n      extractor: (match) => ({\n        label: match[0],\n        properties: {\n          type: 'amount',\n          value: parseFloat(match[0].replace(/[$,]/g, '')),\n          currency: match[0][0],\n        },\n      }),\n    });\n  }\n\n  /**\n   * Add custom entity pattern\n   */\n  addEntityPattern(pattern: EntityPattern): void {\n    this.entityPatterns.push(pattern);\n  }\n\n  /**\n   * Add custom relationship pattern\n   */\n  addRelationshipPattern(pattern: RelationshipPattern): void {\n    this.relationshipPatterns.push(pattern);\n  }\n\n  /**\n   * Extract knowledge from text\n   */\n  async extractFromText(text: string, options: ExtractionOptions = {}): Promise<ExtractedKnowledge> {\n    const nodes: ExtractedNodeData[] = [];\n    const edges: ExtractedEdgeData[] = [];\n    const extractedEntities = new Map<string, ExtractedNodeData>();\n\n    // Extract entities\n    if (options.extractEntities !== false) {\n      for (const pattern of this.entityPatterns) {\n        const matches = Array.from(text.matchAll(pattern.pattern));\n\n        for (const match of matches) {\n          const baseData = pattern.extractor ? pattern.extractor(match) : { label: match[0], properties: {} };\n\n          const nodeData: ExtractedNodeData = {\n            type: pattern.type,\n            label: baseData.label || match[0],\n            properties: baseData.properties || {},\n            confidence: baseData.confidence || 0.7,\n            sourceSessionIds: options.sessionId ? [options.sessionId] : undefined,\n          };\n\n          if (!options.minConfidence || nodeData.confidence >= options.minConfidence) {\n            nodes.push(nodeData);\n            extractedEntities.set(nodeData.label, nodeData);\n          }\n        }\n      }\n    }\n\n    // Extract relationships\n    if (options.extractRelationships !== false && extractedEntities.size > 1) {\n      // Simple co-occurrence based relationships\n      const entities = Array.from(extractedEntities.values());\n      const sentences = text.split(/[.!?]+/);\n\n      for (const sentence of sentences) {\n        const sentenceEntities = entities.filter((e) => sentence.toLowerCase().includes(e.label.toLowerCase()));\n\n        // Create relationships between entities mentioned in the same sentence\n        for (let i = 0; i < sentenceEntities.length; i++) {\n          for (let j = i + 1; j < sentenceEntities.length; j++) {\n            const fromEntity = sentenceEntities[i];\n            const toEntity = sentenceEntities[j];\n            if (!fromEntity || !toEntity) continue;\n\n            const edgeData: ExtractedEdgeData = {\n              type: CommonEdgeType.RELATED_TO,\n              fromNodeLabel: fromEntity.label,\n              toNodeLabel: toEntity.label,\n              properties: { context: 'co-occurrence', sentence: sentence.trim() },\n              confidence: 0.5,\n              sourceSessionIds: options.sessionId ? [options.sessionId] : undefined,\n            };\n\n            if (!options.minConfidence || edgeData.confidence >= options.minConfidence) {\n              edges.push(edgeData);\n            }\n          }\n        }\n      }\n\n      // Apply custom relationship patterns\n      for (const pattern of this.relationshipPatterns) {\n        const matches = Array.from(text.matchAll(pattern.pattern));\n\n        for (const match of matches) {\n          const baseData = pattern.extractor ? pattern.extractor(match, extractedEntities) : null;\n\n          if (baseData) {\n            const edgeData: ExtractedEdgeData = {\n              type: pattern.type,\n              fromNodeLabel: baseData.fromNodeLabel || '',\n              toNodeLabel: baseData.toNodeLabel || '',\n              properties: baseData.properties || {},\n              confidence: baseData.confidence || 0.6,\n              sourceSessionIds: options.sessionId ? [options.sessionId] : undefined,\n            };\n\n            if (!options.minConfidence || edgeData.confidence >= options.minConfidence) {\n              edges.push(edgeData);\n            }\n          }\n        }\n      }\n    }\n\n    // Extract topics\n    const topics: string[] = [];\n    if (options.extractTopics !== false) {\n      const topicKeywords = [\n        'technology',\n        'finance',\n        'health',\n        'education',\n        'business',\n        'science',\n        'politics',\n        'sports',\n        'entertainment',\n        'travel',\n        'food',\n        'art',\n        'music',\n        'environment',\n        'social',\n      ];\n\n      const lowerText = text.toLowerCase();\n      for (const keyword of topicKeywords) {\n        if (lowerText.includes(keyword)) {\n          topics.push(keyword);\n\n          // Add topic as a node\n          nodes.push({\n            type: 'TOPIC',\n            label: keyword,\n            properties: { extracted: true },\n            confidence: 0.8,\n            sourceSessionIds: options.sessionId ? [options.sessionId] : undefined,\n          });\n        }\n      }\n    }\n\n    return {\n      nodes,\n      edges,\n      confidence: this.calculateOverallConfidence(nodes, edges),\n      metadata: {\n        topics,\n        extractedAt: new Date().toISOString(),\n        textLength: text.length,\n        entityCount: nodes.length,\n        relationshipCount: edges.length,\n      },\n    };\n  }\n\n  /**\n   * Extract knowledge from structured data\n   */\n  async extractFromStructured(data: Record<string, any>, options: ExtractionOptions = {}): Promise<ExtractedKnowledge> {\n    const nodes: ExtractedNodeData[] = [];\n    const edges: ExtractedEdgeData[] = [];\n\n    // Recursive extraction from nested objects\n    const extractFromObject = (obj: Record<string, any>, parentLabel?: string, parentType?: NodeType | string) => {\n      for (const [key, value] of Object.entries(obj)) {\n        if (value === null || value === undefined) continue;\n\n        if (typeof value === 'object' && !Array.isArray(value)) {\n          // Create node for nested object\n          const nodeData: ExtractedNodeData = {\n            type: this.inferNodeType(key, value),\n            label: value.name || value.title || value.label || key,\n            properties: { ...value, key },\n            confidence: 0.9,\n            sourceSessionIds: options.sessionId ? [options.sessionId] : undefined,\n          };\n\n          nodes.push(nodeData);\n\n          // Create relationship to parent if exists\n          if (parentLabel) {\n            edges.push({\n              type: CommonEdgeType.PART_OF,\n              fromNodeLabel: nodeData.label,\n              toNodeLabel: parentLabel,\n              properties: { key },\n              confidence: 0.9,\n              sourceSessionIds: options.sessionId ? [options.sessionId] : undefined,\n            });\n          }\n\n          // Recurse into nested object\n          extractFromObject(value, nodeData.label, nodeData.type);\n        } else if (Array.isArray(value)) {\n          // Process arrays\n          for (const item of value) {\n            if (typeof item === 'object') {\n              extractFromObject(item, parentLabel, parentType);\n            }\n          }\n        }\n      }\n    };\n\n    extractFromObject(data);\n\n    return {\n      nodes,\n      edges,\n      confidence: 0.9,\n      metadata: {\n        extractedAt: new Date().toISOString(),\n        dataKeys: Object.keys(data),\n      },\n    };\n  }\n\n  /**\n   * Process extracted knowledge and add to graph\n   */\n  async processExtractedKnowledge(extraction: ExtractedKnowledge, options: ExtractionOptions = {}): Promise<{ nodesAdded: number; edgesAdded: number }> {\n    const nodeMap = new Map<string, string>(); // label -> id mapping\n    let nodesAdded = 0;\n    let edgesAdded = 0;\n\n    // Process nodes\n    for (const nodeData of extraction.nodes) {\n      // Check if node already exists\n      const existingNodes = await this.graph.findNodesByLabel(nodeData.label, true);\n\n      let nodeId: string;\n\n      if (existingNodes.length > 0) {\n        // Node exists - update or skip based on merge strategy\n        const existingNode = existingNodes[0];\n        if (!existingNode) continue;\n\n        nodeId = existingNode.id;\n\n        if (options.mergeStrategy === 'merge') {\n          await this.graph.updateNode(\n            nodeId,\n            {\n              properties: { ...existingNode.properties, ...nodeData.properties },\n              confidence: (existingNode.confidence + nodeData.confidence) / 2,\n              sourceSessionId: options.sessionId,\n            },\n            true\n          );\n        } else if (options.mergeStrategy === 'replace') {\n          await this.graph.updateNode(\n            nodeId,\n            {\n              type: nodeData.type,\n              properties: nodeData.properties,\n              confidence: nodeData.confidence,\n              sourceSessionId: options.sessionId,\n            },\n            false\n          );\n        }\n        // 'skip' - do nothing\n      } else {\n        // Create new node\n        const newNode = await this.graph.addNode({\n          type: nodeData.type,\n          label: nodeData.label,\n          properties: nodeData.properties,\n          confidence: nodeData.confidence,\n          sourceSessionId: options.sessionId,\n        });\n\n        nodeId = newNode.id;\n        nodesAdded++;\n      }\n\n      nodeMap.set(nodeData.label, nodeId);\n    }\n\n    // Process edges\n    for (const edgeData of extraction.edges) {\n      const fromNodeId = nodeMap.get(edgeData.fromNodeLabel);\n      const toNodeId = nodeMap.get(edgeData.toNodeLabel);\n\n      if (fromNodeId && toNodeId) {\n        // Check if edge already exists\n        const existingEdges = await this.graph.getEdgesBetween(fromNodeId, toNodeId, edgeData.type);\n\n        if (existingEdges.length === 0) {\n          await this.graph.addEdge({\n            type: edgeData.type,\n            fromNodeId,\n            toNodeId,\n            properties: edgeData.properties,\n            confidence: edgeData.confidence,\n            sourceSessionId: options.sessionId,\n          });\n\n          edgesAdded++;\n        }\n      }\n    }\n\n    return { nodesAdded, edgesAdded };\n  }\n\n  /**\n   * Extract knowledge from conversation/chat messages\n   */\n  async extractFromConversation(messages: Array<{ role: string; content: string }>, options: ExtractionOptions = {}): Promise<ExtractedKnowledge> {\n    const allNodes: ExtractedNodeData[] = [];\n    const allEdges: ExtractedEdgeData[] = [];\n    const conversationContext: Record<string, any> = {};\n\n    // Track entities across messages\n    const entityMentions = new Map<string, number>();\n\n    for (const message of messages) {\n      const extraction = await this.extractFromText(message.content, options);\n\n      // Boost confidence for repeatedly mentioned entities\n      for (const node of extraction.nodes) {\n        const mentions = (entityMentions.get(node.label) || 0) + 1;\n        entityMentions.set(node.label, mentions);\n\n        node.confidence = Math.min(1.0, node.confidence + (mentions - 1) * 0.1);\n        node.properties = {\n          ...node.properties,\n          role: message.role,\n          mentions,\n        };\n\n        allNodes.push(node);\n      }\n\n      allEdges.push(...extraction.edges);\n\n      // Extract conversation metadata\n      if (message.role === 'user') {\n        conversationContext.userTopics = extraction.metadata?.topics || [];\n      }\n    }\n\n    // Deduplicate nodes with same label\n    const uniqueNodes = new Map<string, ExtractedNodeData>();\n    for (const node of allNodes) {\n      const existing = uniqueNodes.get(node.label);\n      if (existing) {\n        // Merge properties and boost confidence\n        existing.properties = { ...existing.properties, ...node.properties };\n        existing.confidence = Math.min(1.0, (existing.confidence + node.confidence) / 2);\n      } else {\n        uniqueNodes.set(node.label, node);\n      }\n    }\n\n    return {\n      nodes: Array.from(uniqueNodes.values()),\n      edges: allEdges,\n      confidence: this.calculateOverallConfidence(Array.from(uniqueNodes.values()), allEdges),\n      metadata: {\n        messageCount: messages.length,\n        entityMentions: Object.fromEntries(entityMentions),\n        conversationContext,\n        extractedAt: new Date().toISOString(),\n      },\n    };\n  }\n\n  /**\n   * Infer node type from key and value\n   */\n  private inferNodeType(key: string, value: any): string {\n    const lowerKey = key.toLowerCase();\n\n    if (lowerKey.includes('person') || lowerKey.includes('user') || lowerKey.includes('customer')) {\n      return 'PERSON';\n    }\n    if (lowerKey.includes('company') || lowerKey.includes('organization') || lowerKey.includes('org')) {\n      return 'ORGANIZATION';\n    }\n    if (lowerKey.includes('location') || lowerKey.includes('address') || lowerKey.includes('place')) {\n      return 'LOCATION';\n    }\n    if (lowerKey.includes('event') || lowerKey.includes('meeting') || lowerKey.includes('appointment')) {\n      return 'EVENT';\n    }\n    if (lowerKey.includes('product') || lowerKey.includes('item')) {\n      return 'PRODUCT';\n    }\n    if (lowerKey.includes('service')) {\n      return 'SERVICE';\n    }\n    if (lowerKey.includes('document') || lowerKey.includes('file') || lowerKey.includes('report')) {\n      return 'DOCUMENT';\n    }\n    if (lowerKey.includes('skill') || lowerKey.includes('ability')) {\n      return 'SKILL';\n    }\n    if (lowerKey.includes('goal') || lowerKey.includes('objective')) {\n      return 'GOAL';\n    }\n\n    // Check value type\n    if (typeof value === 'object') {\n      if (value.email || value.phone) return 'PERSON';\n      if (value.amount || value.price || value.cost) return 'FINANCIAL';\n      if (value.latitude || value.longitude || value.address) return 'LOCATION';\n    }\n\n    return 'CUSTOM';\n  }\n\n  /**\n   * Calculate overall confidence score\n   */\n  private calculateOverallConfidence(nodes: ExtractedNodeData[], edges: ExtractedEdgeData[]): number {\n    if (nodes.length === 0 && edges.length === 0) return 0;\n\n    const nodeConfidence = nodes.length > 0 ? nodes.reduce((sum, n) => sum + n.confidence, 0) / nodes.length : 0;\n\n    const edgeConfidence = edges.length > 0 ? edges.reduce((sum, e) => sum + e.confidence, 0) / edges.length : 0;\n\n    const weight = nodes.length + edges.length;\n    return (nodeConfidence * nodes.length + edgeConfidence * edges.length) / weight;\n  }\n}\n\n// Export convenience functions\nexport async function extractFromText(graph: KnowledgeGraph, text: string, options?: ExtractionOptions): Promise<ExtractedKnowledge> {\n  const extractor = new KnowledgeExtractor(graph);\n  return extractor.extractFromText(text, options);\n}\n\nexport async function extractFromConversation(graph: KnowledgeGraph, messages: Array<{ role: string; content: string }>, options?: ExtractionOptions): Promise<ExtractedKnowledge> {\n  const extractor = new KnowledgeExtractor(graph);\n  return extractor.extractFromConversation(messages, options);\n}\n\nexport async function processExtractedKnowledge(\n  graph: KnowledgeGraph,\n  extraction: ExtractedKnowledge,\n  options?: ExtractionOptions\n): Promise<{ nodesAdded: number; edgesAdded: number }> {\n  const extractor = new KnowledgeExtractor(graph);\n  return extractor.processExtractedKnowledge(extraction, options);\n}\n","/**\n * Mermaid-based visualization for Knowledge Graphs\n * \n * Generates Mermaid diagram syntax from knowledge graph data,\n * which can be rendered using any Mermaid-compatible renderer.\n */\n\nimport type { KnowledgeGraph } from '../core/KnowledgeGraph';\nimport type { QueryResult, KnowledgeNode, KnowledgeEdge } from '../types';\n\nexport interface MermaidVisualizationOptions {\n  direction?: 'TB' | 'TD' | 'BT' | 'RL' | 'LR';\n  theme?: 'default' | 'dark' | 'forest' | 'neutral';\n  maxNodes?: number;\n  maxEdges?: number;\n  includeProperties?: boolean;\n  nodeTypeStyles?: Record<string, string>;\n  edgeTypeStyles?: Record<string, string>;\n}\n\nexport interface MermaidDiagram {\n  type: 'graph' | 'flowchart';\n  direction: string;\n  content: string;\n  nodeCount: number;\n  edgeCount: number;\n}\n\n/**\n * Generates Mermaid diagram syntax from knowledge graph data\n */\nexport class MermaidGraphVisualizer {\n  constructor(private graph: KnowledgeGraph) {}\n\n  /**\n   * Generate a Mermaid diagram from a query result\n   */\n  generateFromQueryResult(\n    queryResult: QueryResult,\n    options: MermaidVisualizationOptions = {}\n  ): MermaidDiagram {\n    const direction = options.direction || 'TD';\n    const maxNodes = options.maxNodes || 100;\n    const maxEdges = options.maxEdges || 200;\n\n    // Limit nodes and edges\n    const nodes = queryResult.nodes.slice(0, maxNodes);\n    const edges = queryResult.edges.slice(0, maxEdges);\n\n    // Generate Mermaid syntax\n    const lines: string[] = [];\n    lines.push(`graph ${direction}`);\n\n    // Add nodes with proper escaping\n    for (const node of nodes) {\n      const nodeId = this.sanitizeId(node.id);\n      const label = this.formatNodeLabel(node, options.includeProperties);\n      const style = this.getNodeStyle(node.type, options.nodeTypeStyles);\n      \n      lines.push(`    ${nodeId}[\"${label}\"]`);\n      if (style) {\n        lines.push(`    style ${nodeId} ${style}`);\n      }\n    }\n\n    // Add edges\n    const nodeIds = new Set(nodes.map(n => n.id));\n    for (const edge of edges) {\n      // Only include edges where both nodes are in our set\n      if (nodeIds.has(edge.fromNodeId) && nodeIds.has(edge.toNodeId)) {\n        const fromId = this.sanitizeId(edge.fromNodeId);\n        const toId = this.sanitizeId(edge.toNodeId);\n        const label = this.formatEdgeLabel(edge, options.includeProperties);\n        const arrow = '-->';\n        \n        if (label) {\n          lines.push(`    ${fromId} ${arrow}|\"${label}\"| ${toId}`);\n        } else {\n          lines.push(`    ${fromId} ${arrow} ${toId}`);\n        }\n      }\n    }\n\n    return {\n      type: 'graph',\n      direction,\n      content: lines.join('\\n'),\n      nodeCount: nodes.length,\n      edgeCount: edges.filter(e => \n        nodeIds.has(e.fromNodeId) && nodeIds.has(e.toNodeId)\n      ).length,\n    };\n  }\n\n  /**\n   * Generate a Mermaid diagram for a specific node and its neighborhood\n   */\n  async generateFromNode(\n    nodeId: string,\n    depth: number = 2,\n    options: MermaidVisualizationOptions = {}\n  ): Promise<MermaidDiagram> {\n    const queryResult = await this.graph.queryRelated(nodeId, {\n      depth,\n      includeEdges: true,\n    });\n\n    return this.generateFromQueryResult(queryResult, options);\n  }\n\n  /**\n   * Generate a Mermaid diagram from a search query\n   */\n  async generateFromSearch(\n    query: string,\n    options: MermaidVisualizationOptions = {}\n  ): Promise<MermaidDiagram> {\n    const queryResult = await this.graph.search({\n      query,\n      limit: options.maxNodes || 50,\n    });\n\n    return this.generateFromQueryResult(queryResult, options);\n  }\n\n  /**\n   * Generate a Mermaid diagram for specific node types\n   */\n  async generateFromNodeTypes(\n    nodeTypes: string[],\n    options: MermaidVisualizationOptions = {}\n  ): Promise<MermaidDiagram> {\n    const allNodes: KnowledgeNode[] = [];\n    const allEdges: KnowledgeEdge[] = [];\n\n    for (const nodeType of nodeTypes) {\n      const result = await this.graph.queryByType(nodeType, {\n        limit: options.maxNodes || 100,\n        includeEdges: true,\n      });\n      allNodes.push(...result.nodes);\n      allEdges.push(...result.edges);\n    }\n\n    const queryResult: QueryResult = {\n      nodes: allNodes,\n      edges: allEdges,\n    };\n\n    return this.generateFromQueryResult(queryResult, options);\n  }\n\n  /**\n   * Sanitize node ID for Mermaid syntax\n   */\n  private sanitizeId(id: string): string {\n    // Replace problematic characters with underscores\n    return id.replace(/[^a-zA-Z0-9_]/g, '_');\n  }\n\n  /**\n   * Format node label with optional properties\n   */\n  private formatNodeLabel(node: KnowledgeNode, includeProperties?: boolean): string {\n    let label = this.escapeLabel(node.label);\n    \n    if (includeProperties && node.properties && Object.keys(node.properties).length > 0) {\n      const props = Object.entries(node.properties)\n        .slice(0, 3) // Limit to 3 properties for readability\n        .map(([key, value]) => `${key}: ${this.formatValue(value)}`)\n        .join('<br/>');\n      label = `${label}<br/><small>${props}</small>`;\n    }\n\n    return `${node.type}: ${label}`;\n  }\n\n  /**\n   * Format edge label with optional properties\n   */\n  private formatEdgeLabel(edge: KnowledgeEdge, includeProperties?: boolean): string {\n    let label = edge.type.replace(/_/g, ' ').toLowerCase();\n    \n    if (includeProperties && edge.properties && Object.keys(edge.properties).length > 0) {\n      const props = Object.entries(edge.properties)\n        .slice(0, 2) // Limit to 2 properties for readability\n        .map(([key, value]) => `${key}: ${this.formatValue(value)}`)\n        .join(', ');\n      label = `${label} (${props})`;\n    }\n\n    return this.escapeLabel(label);\n  }\n\n  /**\n   * Format property value for display\n   */\n  private formatValue(value: any): string {\n    if (typeof value === 'string') {\n      return value.length > 20 ? value.substring(0, 20) + '...' : value;\n    }\n    if (Array.isArray(value)) {\n      return `[${value.length} items]`;\n    }\n    if (typeof value === 'object' && value !== null) {\n      return '[object]';\n    }\n    return String(value);\n  }\n\n  /**\n   * Escape special characters in labels\n   */\n  private escapeLabel(label: string): string {\n    return label\n      .replace(/\"/g, '&quot;')\n      .replace(/'/g, '&apos;')\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;')\n      .replace(/\\n/g, ' ');\n  }\n\n  /**\n   * Get node style based on type\n   */\n  private getNodeStyle(nodeType: string, customStyles?: Record<string, string>): string {\n    if (customStyles && customStyles[nodeType]) {\n      return customStyles[nodeType];\n    }\n\n    // Default styles for common node types\n    const defaultStyles: Record<string, string> = {\n      PERSON: 'fill:#4CAF50,stroke:#333,stroke-width:2px',\n      ORGANIZATION: 'fill:#2196F3,stroke:#333,stroke-width:2px',\n      LOCATION: 'fill:#FF9800,stroke:#333,stroke-width:2px',\n      DOCUMENT: 'fill:#607D8B,stroke:#333,stroke-width:2px',\n      CONCEPT: 'fill:#9C27B0,stroke:#333,stroke-width:2px',\n      EVENT: 'fill:#F44336,stroke:#333,stroke-width:2px',\n      SKILL: 'fill:#00BCD4,stroke:#333,stroke-width:2px',\n      PRODUCT: 'fill:#FFEB3B,stroke:#333,stroke-width:2px',\n    };\n\n    return defaultStyles[nodeType] || 'fill:#666,stroke:#333,stroke-width:2px';\n  }\n}\n\n/**\n * Utility functions for working with Mermaid diagrams\n */\nexport class MermaidUtils {\n  /**\n   * Wrap Mermaid diagram in HTML for rendering\n   */\n  static wrapInHtml(diagram: MermaidDiagram, options?: {\n    title?: string;\n    theme?: string;\n  }): string {\n    const title = options?.title || 'Knowledge Graph Visualization';\n    const theme = options?.theme || 'default';\n\n    return `<!DOCTYPE html>\n<html>\n<head>\n    <title>${title}</title>\n    <script src=\"https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js\"></script>\n    <script>\n        mermaid.initialize({ \n            startOnLoad: true,\n            theme: '${theme}',\n            flowchart: {\n                useMaxWidth: true,\n                htmlLabels: true,\n                curve: 'basis'\n            }\n        });\n    </script>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            margin: 20px;\n            background: #f5f5f5;\n        }\n        .mermaid {\n            background: white;\n            padding: 20px;\n            border-radius: 8px;\n            box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n        }\n        .info {\n            margin-top: 20px;\n            padding: 10px;\n            background: #e3f2fd;\n            border-radius: 4px;\n        }\n    </style>\n</head>\n<body>\n    <h1>${title}</h1>\n    <div class=\"mermaid\">\n${diagram.content}\n    </div>\n    <div class=\"info\">\n        <strong>Graph Statistics:</strong> ${diagram.nodeCount} nodes, ${diagram.edgeCount} edges\n    </div>\n</body>\n</html>`;\n  }\n\n  /**\n   * Generate a URL for rendering with Mermaid Live Editor\n   */\n  static generateLiveEditorUrl(diagram: MermaidDiagram): string {\n    const base64 = Buffer.from(diagram.content).toString('base64');\n    \n    return `https://mermaid.live/edit#pako:${base64}`;\n  }\n\n  /**\n   * Convert diagram to Markdown with Mermaid code block\n   */\n  static toMarkdown(diagram: MermaidDiagram, title?: string): string {\n    const header = title ? `# ${title}\\n\\n` : '';\n    return `${header}\\`\\`\\`mermaid\n${diagram.content}\n\\`\\`\\`\n\n**Graph Statistics:** ${diagram.nodeCount} nodes, ${diagram.edgeCount} edges`;\n  }\n}\n\n// Export for backward compatibility\nexport { MermaidGraphVisualizer as GraphVisualizationManager };\nexport type { MermaidDiagram as GraphSnapshot };\n\n// Stub exports for backward compatibility\nexport const PerformanceUtils = {\n  isSuitableForRealTime: (nodeCount: number, _edgeCount: number) => nodeCount < 100,\n  getRecommendedBackend: (_nodeCount: number, _edgeCount: number) => 'mermaid' as const,\n};\n\nexport const ColorUtils = {\n  generateNodeColorPalette: (types: string[]) => {\n    const colors: Record<string, string> = {};\n    const palette = ['#4CAF50', '#2196F3', '#FF9800', '#9C27B0', '#F44336', '#00BCD4'];\n    types.forEach((type, i) => {\n      colors[type] = palette[i % palette.length] || '#666666';\n    });\n    return colors;\n  },\n  generateEdgeColorPalette: (types: string[]) => {\n    const colors: Record<string, string> = {};\n    types.forEach(type => {\n      colors[type] = '#666666';\n    });\n    return colors;\n  },\n};\n\nexport const LayoutUtils = {\n  getLayoutOptionsForGraphSize: (nodeCount: number, _edgeCount: number) => {\n    if (nodeCount < 20) return { layout: 'TD' as const };\n    if (nodeCount < 50) return { layout: 'LR' as const };\n    return { layout: 'TB' as const };\n  },\n  calculateOptimalNodeSizes: (nodesByType: Record<string, number>, _total: number) => {\n    const sizes: Record<string, number> = {};\n    Object.keys(nodesByType).forEach(type => {\n      sizes[type] = 15;\n    });\n    return sizes;\n  },\n  calculateOptimalEdgeWidths: (edgesByType: Record<string, number>, _total: number) => {\n    const widths: Record<string, number> = {};\n    Object.keys(edgesByType).forEach(type => {\n      widths[type] = 2;\n    });\n    return widths;\n  },\n};\n\nexport type VisualizationBackend = 'mermaid';"],"mappings":"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","names":["nodes","edges","CommonEdgeType","import_better_sqlite3","Database","index","nodes","edges","index","nodes","edges","index","nodes","edges","text","nodes","edges","nodes","edges"]}